class MechLabCursor : MenuCursor {}

class MechItemSlot : MenuElement
{
	MechHardpointContainer container;
	vector2 defaultPos;
	MechItem slotItem;
	double slotHeight;
	double scale;
	double alpha;

	override void Init()
	{
		super.Init();
		defaultPos = pos;
		slotHeight = size.y;
		scale = 0.5;
		alpha = 1.0;
	}
	
	override void Draw(double dT)
	{
		Font itemFont = "SmallFont"; 
		
		Color slotColor = 0;
		uint itemFontColor = Font.CR_WHITE;
		if(slotItem) 
		{	
			bool isDynamic = slotItem is "MechDynamicStructure";
			if(!slotItem.movable && !isDynamic)
			{
				itemFontColor = Font.CR_BLACK;
			}
			else
			{
				let weap = MechWeapon(slotItem);
				if(weap)
				{
					if(weap.mountType ~== "energy"   ) slotColor = 0xA0FFFF00;
					if(weap.mountType ~== "ballistic") slotColor = 0xA00000FF;
					if(weap.mountType ~== "missile"  ) slotColor = 0xA000FF00;
				}
				
				if(isDynamic)
				{
					itemFontColor = Font.CR_BLACK;
					slotColor = 0xB2000000;
				}
				
				if(slotItem is "MechAmmo")
					slotColor = 0xA0FF00FF;
				
				if(slotItem is "MechEngine")
					slotColor = 0xA0FF0000;
			}
		}
		MWDrawer.DrawImage("Graphics/Mechlab/itemTop.png", pos, alpha:alpha, scale:(scale,scale), tint:slotColor, texoffs:(0,0));
		
		if(slotItem)
		{
			int itemSize = max(1,slotItem.size);
			double scaledSlotHeight = slotHeight * scale;
			for(int i = 0; i < itemSize-1; i++)
			{
				MWDrawer.DrawImage(
					"Graphics/Mechlab/itemBottom.png", 
					pos + (0, scaledSlotHeight + (i * scaledSlotHeight)), 
					alpha:alpha, scale:(scale,scale), tint:slotColor, 
					texoffs:(0,0)
				);
			}
			
			// Draw item data
			double fontScale = scale * 1.75;
			vector2 centerPos = pos + (
				(size.x / 2.0),
				(size.y / 2.0) - ( (itemFont.GetHeight() * (2.0*fontScale) ) / 2.0 )
			);
			
			MWDrawer.DrawString(
				itemFont, slotItem.displayName, 
				centerPos, MWDrawer.SS_TEXT_CENTER, itemFontColor,
				alpha, scale:(fontScale, fontScale)
			);
		}
		
		// drawCollider();
	}
	
	override bool checkDraggable()
	{
		return slotItem && slotItem.movable;
	}
	
	override void updateDragPos(MenuCursor cursor)
	{
		pos = cursor.pos - (
			(size.x / 2.0) - (cursor.size.x / 2.0), 
			(size.y / 2.0) + 4
		);
	}
	
	override void OnDrop(MenuCursor cursor)
	{
		let mechlab = MechMenu_MechLab(parentMenu);
		if(!mechlab) return;
		
		let dropContainer = MechHardpointContainer(getCollidingWithType("MechHardpointContainer"));
		string itemIDs = mechlab.mech.getMechItemIndex(slotItem);
				
		if(dropContainer == container) 
		{
			// Drop
			pos = defaultPos; 
			return;
		}
		else if(dropContainer)
		{
			// Move
			pos = defaultPos; 
			EventHandler.SendNetworkEvent(String.Format("mechlab.item.move.%s.%d", itemIDs, dropContainer.partID));
			return;
		}
		else
		{
			// Dequip
			EventHandler.SendNetworkEvent(String.Format("mechlab.item.dequip.%s", itemIDs));
		}
	}
	
	override void Update(double dT)
	{
		// Update size to item slot size.
		double scaledSlotHeight = slotHeight * scale;
		size.y = slotItem ? scaledSlotHeight * max(1,slotItem.size) : scaledSlotHeight;
	}
}

class MechHardpointContainer : MenuElement
{
	int partID;
	MechMenu_Mechlab mechlab;
	MechHardpoint hardpoint;
	Array<MechItemSlot> slots;
	double slotsWidth, slotsHeight;
	double itemSpacing;
		
	virtual void Setup(MechHardpoint hardpoint, double slotsWidth, double slotsHeight)
	{
		self.hardpoint = hardpoint;
		self.slotsHeight = slotsHeight;
		self.slotsWidth = slotsWidth;
		mechlab = MechMenu_Mechlab(parentMenu);
		itemSpacing = 0; //slotsHeight * (1/8.);
		
		if(!mechlab.mech) return;
		
		// Find hardpoint partID
		for(int i = 0; i < mechlab.mech.parts.Size(); i++)
		{
			let hp = MechHardpoint(mechlab.mech.parts[i]);
			if(hp == hardpoint) 
			{
				partID = i;
				break;
			}
		}
		
		// Create all slots
		for(int i = 0; i < hardpoint.maxslots; i++)
		{
			let menuSlot = MechItemSlot(MenuElement.Create(
				"MechItemSlot", String.Format("Slot#%d", i), 
				parentMenu, pos, (slotsWidth,slotsHeight)
			));
			menuSlot.container = self;
			slots.Push(menuSlot);
		}
	}
	
	override void Update(double dT)
	{	
		// Update all slot item pointers.
		int fillSlot = 0;
		for(int i = 0; i < hardpoint.items.Size(); i++)
		{
			if(hardpoint.items[i] is "MechDynamicStructure") continue;
			
			let curSlot = slots[fillSlot];
			let prevItem = curSlot.slotItem;
			curSlot.slotItem = hardpoint.items[i];
			
			// Update slot position(s)
			if(prevItem != curSlot.slotItem)
				curSlot.pos.x = pos.x;
				
			curSlot.Update(dT);
			fillSlot++;
			
			// Mouse collisions
			mechlab.cursor.CheckCollision(curSlot);
		}	
		
		// Setup slots for dynamic structures
		for(int i = 0; i < hardpoint.items.Size(); i++)
		{
			if( !(hardpoint.items[i] is "MechDynamicStructure") ) continue;
			
			let curSlot = slots[fillSlot];
			let prevItem = curSlot.slotItem;
			curSlot.slotItem = hardpoint.items[i];
			
			// Update slot position(s)
			if(prevItem != curSlot.slotItem)
				curSlot.pos.x = pos.x;
			
			curSlot.Update(dT);
			
			fillSlot++;
			
			// Mouse collisions
			mechlab.cursor.CheckCollision(curSlot);
		}
		
		size.y = 1 + (((slotsHeight*slots[0].scale) + itemSpacing) * slots.Size());
	}
	
	override void Draw(double dT)
	{
		if(!mechlab) return;
		
		// Background
		MWDrawer.Fill("Black", pos.x,pos.y, size.x, size.y);
		MWDrawer.DrawRect(pos, size, "Gray");
				
		double drawY = 0;
		double slotSpacing = (slotsHeight*slots[0].scale) + itemSpacing;
		for(int i = 0; i < hardpoint.maxslots; i++)
		{
			MWDrawer.DrawString("ConsoleFont", "-", (pos.x + 8, pos.y + drawY));
			MWDrawer.DrawThickLine(pos.x, pos.y + drawY + slotSpacing, pos.x + size.x, pos.y + drawY + slotSpacing, 2, "Gray"); 
			drawY += slotSpacing;
		}
				
		// Update slot draw positions
		drawY = 0;
		for(int i = 0; i < hardpoint.items.Size(); i++)
		{	
			let slot = slots[i];
			// Skip if item is being dragged.
			if(mechlab.cursor.draggingElement == slot) continue;
			
			if(slot.slotItem)
			{
				slot.pos.y = pos.y + drawY;
				slot.Draw(dT);
				drawY += (slotSpacing * max(1, slot.slotItem.size));
				if(drawY < size.y) 
					MWDrawer.DrawThickLine(pos.x, pos.y + drawY, pos.x + size.x, pos.y + drawY, 4, "Black", slot.alpha); 
			}
		}
		
	}
}

class MechMenu_Mechlab : MechMenu 
{
	MechLabCursor cursor;
	DrivableMech mech;
	
	override void InitElements() 
	{
		// Get active mech.
		let drvObj = I_DrivingObject.Get(players[consoleplayer].mo);
		if(drvObj && drvObj.source) mech = DrivableMech(drvObj.source);
		
		let leftArmSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_LA", (200,200), (256,256))
		);
		leftArmSlots.Setup(mech.leftArm, 256, 34);
		
		let leftTorsoSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_LT", (500,200), (256,256))
		);
		leftTorsoSlots.Setup(mech.leftTorso, 256, 34);
		
		let centerTorsoSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_CT", (800,200), (256,256))
		);
		centerTorsoSlots.Setup(mech.torso, 256, 34);
		
		let rightTorsoSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_RT", (1100,200), (256,256))
		);
		rightTorsoSlots.Setup(mech.rightTorso, 256, 34);
		
		let rightArmSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_RA", (1400,200), (256,256))
		);
		rightArmSlots.Setup(mech.rightArm, 256, 34);
		
		
		// Cursor is added last, to keep always on-top.
		cursor = MechLabCursor(AddElement("MechLabCursor", "Cursor", (0,0), (16,16))); 
		
		/*
		let testSlot = MechItemSlot(AddElement("MechItemSlot", "TestSlot", (200,400), (256,34)));
		testSlot.slotItem = mech.FindItem("LRM20");
		*/
	}
	
	override void processNetworkEvent(ConsoleEvent e)
	{
		// Used as a callback from NetworkProcess, primarily to keep
		// code functionality organized and more readable.
	}
	
	override void OnElementEvent(MenuElement source, string eventType, int intArg, double doubleArg, Object objArg)
	{
		// MenuElements can call this function if they wish to relay behavior to their parent menu.
	}
}