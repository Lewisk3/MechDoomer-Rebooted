class MechLabCursor : MenuCursor {}

// Hardpoint Container
class MechHardpointContainer : MenuElement
{
	int partID;
	MechMenu_Mechlab mechlab;
	MechHardpoint hardpoint;
	Array<MechItemSlot> slots;
	double slotsWidth, slotsHeight;
	double itemSpacing;
	string containerName;
	MechItemSlot mouseHoverSlot;
	
	Array<MechlabSquareButton> buttons;
		
	virtual void Setup(string title, MechHardpoint hardpoint, double slotsWidth, double slotsHeight)
	{
		self.hardpoint = hardpoint;
		self.slotsHeight = slotsHeight;
		self.slotsWidth = slotsWidth;
		self.containerName = title;
		mechlab = MechMenu_Mechlab(parentMenu);
		itemSpacing = 0; //slotsHeight * (1/8.);
		
		if(!mechlab.mech) return;
		
		// Find hardpoint partID
		for(int i = 0; i < mechlab.mech.parts.Size(); i++)
		{
			let hp = MechHardpoint(mechlab.mech.parts[i]);
			if(hp == hardpoint) 
			{
				partID = i;
				break;
			}
		}
		
		vector2 btnPos = pos + (0,-94);
		double btnSize = 12;
		double btnDist = 20;
		
		double xPos = hardpoint.hasRearArmor ? size.x*0.45 : size.x*0.60;
		btnPos.x = pos.x+xPos;
		
		let armorPlusButton = MechlabSquareButton(
			MenuElement.Create("MechlabSquareButton", "ArmorUP", parentMenu, btnPos, (btnSize,btnSize))
		);
		let armorMinusButton = MechlabSquareButton(
			MenuElement.Create("MechlabSquareButton", "ArmorDOWN", parentMenu, btnPos + (0,btnDist), (btnSize,btnSize))
		);
		
		if(hardpoint.hasRearArmor)
		{
			btnPos.x = pos.x + (size.x*0.80);
			let rearArmorPlusButton = MechlabSquareButton(
				MenuElement.Create("MechlabSquareButton", "rearArmorUP", parentMenu, btnPos, (btnSize,btnSize))
			);
			let rearArmorMinusButton = MechlabSquareButton(
				MenuElement.Create("MechlabSquareButton", "rearArmorDOWN", parentMenu, btnPos + (0,btnDist), (btnSize,btnSize))
			);
			
			rearArmorPlusButton.Setup("+");
			rearArmorMinusButton.Setup("-");
			buttons.push(rearArmorPlusButton);
			buttons.push(rearArmorMinusButton);
		}
		
		armorPlusButton.Setup("+");
		armorMinusButton.Setup("-");
		buttons.push(armorPlusButton);
		buttons.push(armorMinusButton);
		
		// Create all slots
		for(uint i = 0; i < hardpoint.maxslots; i++)
		{
			let menuSlot = MechItemSlot(MenuElement.Create(
				"MechItemSlot", String.Format("Slot#%d", i), 
				parentMenu, pos, (slotsWidth,slotsHeight)
			));
			menuSlot.container = self;
			slots.Push(menuSlot);
		}
	}
	
	void updateSlotItem(double dT, int fillslot, int itemIndex)
	{
		let curSlot = slots[fillSlot];
		let prevItem = curSlot.slotItem;
		curSlot.slotItem = hardpoint.items[itemIndex];
		curSlot.Update(dT);
			
		fillSlot++;
			
		// Mouse collisions
		if(mechlab.cursor.CheckCollision(curSlot))
			mouseHoverSlot = curSlot;
	}
	
	override void Update(double dT)
	{	
		// Update all slot item pointers.
		int fillSlot = 0;
		for(int i = 0; i < hardpoint.items.Size(); i++)
		{
			if(hardpoint.items[i] is "MechDynamicStructure") continue;
			updateSlotItem(dT, fillslot++, i); 
		}	
		
		// Setup slots for dynamic structures
		// Has to be processed last
		for(int i = 0; i < hardpoint.items.Size(); i++)
		{
			if( !(hardpoint.items[i] is "MechDynamicStructure") ) continue;
			updateSlotItem(dT, fillslot++, i); 
		}
				
		size.y = 1 + (((slotsHeight*slots[0].scale) + itemSpacing) * slots.Size());
		disabled = hardpoint.healthPoints <= 0;
	}
	
	void filterMountpoints(out Array<HardpointMount> mounts)
	{
		// Filter used mount points, process used mount points by dragged item as unusued.
		let draggingItem = MechItemSlot(mechlab.cursor.draggingElement);
		for(int i = mounts.size()-1; i >= 0; i--)
		{
			let mnt = mounts[i];
			if( mnt.mountedItem && (!draggingItem || mnt.mountedItem != draggingItem.slotItem) )
				mounts.Delete(i);
		}
	}
	
	virtual void DrawHardpointMount(Name type, int count, vector2 drawPos, double iconScale = 1.0)
	{
		Name mountType = type;
		string mountGraphic = HardpointMount.getMountGraphic(type);
		vector2 txtPos = drawPos + (15, -8);
		
		MWDrawer.DrawImage(mountGraphic, drawPos, scale:(iconScale,iconScale));
		MWDrawer.DrawString("ConsoleFont", ""..count, txtPos, translation:Font.CR_GREEN); 
	}
	
	override void Draw(double dT)
	{
		if(!mechlab) return;
		
		double wScale = slotsWidth / 256.;
		
		// Draw top-bar
		vector2 topBarPos = pos - (0,130);
		double topBarHeight = 120;
		
		MWDrawer.DrawImage(
			"Graphics/Mechlab/itemTop.png", 
			topBarPos - (0,3), scale:(-wScale*0.45, 0.6), 
			tint:0xFF1A1A1A, texoffs:(2,1)
		);
		
		MWDrawer.DrawString("bt_classic", containerName, topBarPos + (8,-12), translation:Font.CR_BLACK, scale:(0.9,1.0)); 
		MWDrawer.DrawString("bt_classic", containerName, topBarPos + (8,-12), translation:Font.CR_WHITE, alpha:0.27, scale:(0.9,1.0)); 
		
		Array<HardpointMount> energyPoints, ballisticPoints, missilePoints, podPoints;
		hardpoint.getMountPoints(energyPoints, "Energy");
		hardpoint.getMountPoints(ballisticPoints, "Ballistic");
		hardpoint.getMountPoints(missilePoints, "Missile");
		hardpoint.getMountPoints(podPoints, "PDS");
		filterMountpoints(energyPoints);
		filterMountpoints(ballisticPoints);
		filterMountpoints(missilePoints);
		filterMountpoints(podPoints);
		
		double frontArmor = floor(hardpoint.armorPoints);
		double rearArmor = floor(hardpoint.hasRearArmor ? hardpoint.rearArmor : -1);
		
		MWDrawer.Fill("Black", topBarPos.x,topBarPos.y + 8, size.x, topBarHeight);
		MWDrawer.DrawRect(topBarPos + (0,8), (size.x,topBarHeight), "Gray");
		
		MWDrawer.Fill("DarkGray", topBarPos.x,topBarPos.y + 9, size.x, 20);
		MWDrawer.DrawString("bt_classic", "ARMOR", topBarPos + (5,9), translation:Font.CR_GRAY); 
		
		// Armor Points
		double reserveArmorPoints = hardpoint.getReserveArmorPoints(); //ceil(hardpoint.maxArmor - (max(0,frontArmor) + max(0, rearArmor)));
		MWDrawer.DrawString("hm_type", ""..int(reserveArmorPoints), topBarPos + (190,6), MWDrawer.SS_TEXT_RIGHT, translation:Font.CR_Sapphire, scale:(0.8,0.8)); 
		
		// Damage
		MWDrawer.DrawString("hm_type", String.Format("-%.2f", hardpoint.armorDamage), topBarPos + (92,7), translation:Font.CR_Brick, scale:(0.65,0.65)); 
		
		MWDrawer.DrawString("hm_type", ""..int(frontArmor), topBarPos + (rearArmor >= 0 ? size.x*0.25 : size.x*0.4,45));
		if(rearArmor >= 0)
			MWDrawer.DrawString("hm_type", ""..int(rearArmor), topBarPos + (size.x*0.6,45));
		
		// Weapon types
		MWDrawer.Fill("DarkGray", topBarPos.x,topBarPos.y + 80, size.x, 20);
		MWDrawer.DrawString("bt_classic", "STRUCTURE", topBarPos + (5,80), translation:Font.CR_GRAY); 
		MWDrawer.DrawString("hm_type", ""..max(0,int(ceil(hardpoint.healthPoints))), topBarPos + (160,77), translation:Font.CR_RED, scale:(0.8,0.8)); 
		
		double iconScale = 0.5;
		vector2 mountOffs = (10,113);
		double spacing = 50;
		
		DrawHardpointMount('energy', energyPoints.Size(), topBarPos + mountOffs, iconScale);
		mountOffs.x += spacing;
		DrawHardpointMount('ballistic', ballisticPoints.Size(), topBarPos + mountOffs, iconScale);
		mountOffs.x += spacing;
		DrawHardpointMount('missile', missilePoints.Size(), topBarPos + mountOffs, iconScale);
		mountOffs.x += spacing;
		DrawHardpointMount('pds', podPoints.Size(), topBarPos + mountOffs, iconScale);
		mountOffs.x += spacing;
		
		// Background
		MWDrawer.Fill("Black", pos.x,pos.y, size.x, size.y);
		MWDrawer.DrawRect(pos, size, "Gray");
				
		double drawY = 0;
		double slotSpacing = (slotsHeight*slots[0].scale) + itemSpacing;
		for(uint i = 0; i < hardpoint.maxslots; i++)
		{
			MWDrawer.DrawString("hm_type", "-", (pos.x + 8, pos.y + drawY - 5));
			MWDrawer.DrawThickLine(pos.x, pos.y + drawY + slotSpacing, pos.x + size.x, pos.y + drawY + slotSpacing, 2, "Gray"); 
			drawY += slotSpacing;
		}
		
		// Buttons
		for(int i = 0; i < buttons.Size(); i++)
		{
			let btn = buttons[i];	
				
			if( btn.Tag.IndexOf("UP") != -1 )
				btn.disabled = reserveArmorPoints <= 0;
			if( btn.Tag ~== "ArmorDOWN")
				btn.disabled = hardpoint.armorPoints <= 0;
			if( btn.Tag ~== "rearArmorDOWN")
				btn.disabled = hardpoint.rearArmor <= 0;	
			if(disabled || !!mechlab.mech.driver) btn.disabled = true;
				
			if(btn.pressed && !btn.disabled)
			{			
				if(btn.Tag ~== "ArmorUP")
				{
					EventHandler.SendNetworkEvent(
						String.Format("mechlab.armor.front.add.%d.%d", partID, 1)
					);
				}
				else if(btn.Tag ~== "rearArmorUP")
				{
					EventHandler.SendNetworkEvent(
						String.Format("mechlab.armor.rear.add.%d.%d", partID, 1)
					);
				}
				else if(btn.Tag ~== "ArmorDOWN")
				{
					EventHandler.SendNetworkEvent(
						String.Format("mechlab.armor.front.remove.%d.%d", partID, 1)
					);
				}
				else if(btn.Tag ~== "rearArmorDOWN")
				{
					EventHandler.SendNetworkEvent(
						String.Format("mechlab.armor.rear.remove.%d.%d", partID, 1)
					);
				}
				btn.pressed = false;
			}
			
			btn.Draw(dT);
			btn.Update(dT);
			
			// Mouse collisions
			mechlab.cursor.CheckCollision(btn);
		
		}
		
		// Update slot draw positions
		drawY = 0;
		for(int i = 0; i < hardpoint.items.Size(); i++)
		{	
			let slot = slots[i];
			
			// Draw Item stats
				if(mechlab.cursor.CheckCollision(slot, false) && slot && slot.slotItem)
					MenuItemsInvContainer.DrawItemStats(mechlab, slot.slotItem, (340,250), 350);
			
			// Skip if item is being dragged.
			if(mechlab.cursor.draggingElement == slot) continue;
			
			if(slot.slotItem)
			{
				slot.pos.x = pos.x;
				slot.pos.y = pos.y + drawY;
				slot.Draw(dT);
				drawY += (slotSpacing * max(1, slot.slotItem.size));
				if(drawY < size.y-12) 
					MWDrawer.DrawThickLine(pos.x, pos.y + drawY, pos.x + size.x, pos.y + drawY, 4, "Black", slot.alpha); 
			}
		}
		
	}
}

class MechItemSlot : MenuElement
{
	MechMenu_MechLab mechlab;
	MechHardpointContainer container;
	vector2 defaultPos;
	MechItem slotItem;
	double slotHeight;
	double scale;
	double alpha;
	bool locked; // If true, disables dragging on this item.

	override void Init()
	{
		super.Init();
		mechlab = MechMenu_MechLab(parentMenu);
		defaultPos = pos;
		slotHeight = size.y;
		scale = 0.5;
		alpha = 1.0;
	}
	
	static Color, Color GetItemColors(MechItem item)
	{
		int slotColor = 0;
		int itemFontColor = Font.CR_WHITE;
		if(!item) return itemFontColor, slotColor;
		
		item.getUIColors(itemFontColor, slotColor);
		return itemFontColor, Color(slotColor);
	}
	
	ui static void DrawMechItem(MechItem item, vector2 pos, double alpha, double itemScale, vector2 containerSize, double slotHeight, bool greyed = false)
	{
		if(!item) return;
	
		Font itemFont = "hm_type"; 
		bool destroyed = item.checkDestroyed();
		
		Color slotColor = 0;
		uint itemFontColor = Font.CR_WHITE;
		double wScale = containerSize.x / 256;
		
		[itemFontColor, slotColor] = GetItemColors(item);
		if(greyed)
		{
			slotColor = 0xFF000000;
			itemFontColor = Font.CR_White;
		}
		
		if(destroyed)
		{
			slotColor = 0xFFFF0000;
			itemFontColor = Font.CR_Black; 
		}
		
		MWDrawer.DrawImage("Graphics/Mechlab/itemTop.png", pos, alpha:alpha, scale:(itemScale*wScale,itemScale), tint:slotColor, texoffs:(0,0));
		
		if(item)
		{
			int itemSize = max(1,item.size);
			double scaledSlotHeight = slotHeight * itemScale;
			for(int i = 0; i < itemSize-1; i++)
			{
				MWDrawer.DrawImage(
					"Graphics/Mechlab/itemBottom.png", 
					pos + (0, scaledSlotHeight + (i * scaledSlotHeight)), 
					alpha:alpha, scale:(itemScale*wScale,itemScale), tint:slotColor, 
					texoffs:(0,0)
				);
			}
			
			// Draw item data
			double fontScale = itemScale * 1.5;
			vector2 centerPos = pos + (
				(containerSize.x / 2.0),
				(containerSize.y / 2.0) - ( (itemFont.GetHeight() * (2.0*fontScale) ) / 2.0 ) - 1
			);
						
			// Autofit 
			double fitX = containerSize.x - 16;
			double itemNameWidth = itemFont.StringWidth(item.displayName) * fontScale * 2.0;
			double fitScale = itemNameWidth > fitX ? fitX / itemNameWidth : 1.0;
			
			MWDrawer.DrawString(
				itemFont, item.displayName, 
				centerPos, MWDrawer.SS_TEXT_CENTER, itemFontColor,
				alpha, scale:(fontScale * fitScale, fontScale)
			);
		}
	}
	
	override void Draw(double dT)
	{
		DrawMechItem(slotItem, pos, alpha, scale, size, slotHeight, disabled);
	
		// drawCollider();
	}
	
	
	override bool checkDraggable()
	{	
		return slotItem && slotItem.movable;
	}
	
	override void updateDragPos(MenuCursor cursor)
	{
		pos = cursor.pos - (
			(size.x / 2.0) - (cursor.size.x / 2.0), 
			(size.y / 2.0) + 4
		);
	}
	
	override void OnDrop(MenuCursor cursor)
	{
		if(!mechlab || !cursor) return;
		
		if(locked) 
		{
			MDRDialogMenu.Open(mechlab, "Hardmount", "Only ammo can be modified while mech is in active use.", "Continue");
			return;
		}
		
		let mouseOverContainer = MechHardpointContainer(cursor.getCollidingWithType("MechHardpointContainer"));
		string itemIDs = mechlab.mech.getMechItemIndex(slotItem);
				
		if( mouseOverContainer && mouseOverContainer == container ) 
		{
			// Drop
			pos = defaultPos; 
			return;
		}
		else if(mouseOverContainer)
		{
			// Move
			pos = defaultPos; 
			EventHandler.SendNetworkEvent(String.Format("mechlab.item.move.%s.%d", itemIDs, mouseOverContainer.partID));
			return;
		}
		else 
		{
			// Dequip
			EventHandler.SendNetworkEvent(String.Format("mechlab.item.dequip.%s", itemIDs));
		}
	}
	
	override void Update(double dT)
	{
		// Update size to item slot size.
		double scaledSlotHeight = slotHeight * scale;
		size.y = slotItem ? scaledSlotHeight * max(1,slotItem.size) : scaledSlotHeight;
		disabled = container ? container.disabled : false;
		
		// Disable hard-pointed items such as weapons, from being moved while the mech is being piloted.
		locked = (mechlab.mech.driver && !(slotItem is "MechAmmo"));
	}
}

// Inventory container
class MenuItemsInvContainer : MenuElement
{
	MechMenu_Mechlab mechlab;
	
	Array<MechInvItem> invItems;
	Array<int> itemIndexes;
	Array<MechItemSortTab> tabs;
	
	double scroll, scrollVel, scrollMax;
	MechContainerScrollBar scrollBar;
	
	string itemSearch;
	
	override void Init()
	{
		mechlab = MechMenu_Mechlab(parentMenu);
		if(!mechlab || !mechlab.mech) return;
		
		scrollBar = MechContainerScrollBar(
			MenuElement.Create("MechContainerScrollBar", "invScrollBar", parentMenu, pos+(size.x-32,0), (16,0))
		);
		scrollBar.Setup(self);
		
		vector2 tabPos = (36, -190);
		vector2 tabOffs = (0, 0);
		double tabSpacing = size.x * 0.3;
		vector2 tabSize = (size.x/4.,42);
		double tabTextScale = 0.82 * (size.x/480.);
		
		let energyTab = MechWeaponSortTab(
			MenuElement.Create("MechWeaponSortTab", "tabEnergy", parentMenu, pos+tabPos+tabOffs, tabSize)
		);
		energyTab.Setup("Energy", "", textScale:(tabTextScale,tabTextScale));
		energyTab.parentContainer = self;
		energyTab.weapType = "Energy";
		energyTab.active = false;
		tabOffs.x += tabSpacing;
		
		let ballisticsTab = MechWeaponSortTab(
			MenuElement.Create("MechWeaponSortTab", "tabBallistic", parentMenu, pos+tabPos+tabOffs, tabSize)
		);
		ballisticsTab.Setup("Ballistics", "", textScale:(tabTextScale,tabTextScale));
		ballisticsTab.parentContainer = self;
		ballisticsTab.weapType = "Ballistic";
		ballisticsTab.active = false;
		tabOffs.x += tabSpacing;
		
		let missileTab = MechWeaponSortTab(
			MenuElement.Create("MechWeaponSortTab", "tabMissile", parentMenu, pos+tabPos+tabOffs, tabSize)
		);
		missileTab.Setup("Missiles", "", textScale:(tabTextScale,tabTextScale));
		missileTab.parentContainer = self;
		missileTab.weapType = "Missile";
		missileTab.active = false;
		tabOffs.x = 0;
		tabOffs.y += tabSpacing * (0.05+(tabSize.y/tabSize.x));	
		
		let ammoTab = MechItemSortTab(
			MenuElement.Create("MechItemSortTab", "tabAmmo", parentMenu, pos+tabPos+tabOffs, tabSize)
		);
		ammoTab.Setup("Ammo", "", textScale:(tabTextScale,tabTextScale));
		ammoTab.parentContainer = self;
		ammoTab.sortCls = "MechAmmo";
		ammoTab.active = false;
		tabOffs.x += tabSpacing;
		
		let equipmentTab = MechEquipmentSortTab(
			MenuElement.Create("MechEquipmentSortTab", "tabEquipment", parentMenu, pos+tabPos+tabOffs, tabSize)
		);
		equipmentTab.Setup("Equipment", "", textScale:(tabTextScale,tabTextScale));
		equipmentTab.parentContainer = self;
		equipmentTab.active = false;
		tabOffs.x += tabSpacing;
		
		let armorTab = MechRepairKitSortTab(
			MenuElement.Create("MechRepairKitSortTab", "tabRepair", parentMenu, pos+tabPos+tabOffs, tabSize)
		);
		armorTab.Setup("Repair Kits", "", textScale:(tabTextScale,tabTextScale));
		armorTab.parentContainer = self;
		armorTab.active = false;
		tabOffs.x += tabSpacing;

		tabs.Push(energyTab);
		tabs.Push(ballisticsTab);
		tabs.Push(missileTab);
		tabs.Push(ammoTab);
		tabs.Push(equipmentTab);
		tabs.Push(armorTab);
		
		// SearchBar
		AddChild(mechlab, "InvContainerSearchBar", "SearchBar", pos + tabPos + (-10, tabOffs.y + 60), (size.x - 40, 30));
	}
	
	void DoSearchFilter(string search)
	{
		itemSearch = search;
	}
		
	static void DrawItemStats(MechMenu_Mechlab mechlab, MechItem invItem, vector2 pos, double width)
	{
		if(invItem is "MechDynamicStructure") return;
		
		string itemName = invItem.displayName;
		
		string itemFlavorText;
		Array<string> itemStatName, itemStatValue;
		invItem.getDescription(itemFlavorText, itemStatName, itemStatValue, mechlab.mech);
		if(itemStatValue.Size() < itemStatName.Size()) 
			itemStatValue.Resize(itemStatName.Size() - itemStatValue.Size());
		
		Font descFont = "hm_thin";
		Font flavorFont = "hm_type";
		double descFontScale = 0.9;
		double descSpacing = 10;
		double boxHeight = 60. + (itemStatName.Size() * ((descFont.getHeight()*1.5*descFontScale) + (descSpacing*1.2)));
		double boxWidth = width + 10;
				
		BrokenLines flavorTextLines = flavorFont.BreakLines(itemFlavorText, (boxWidth * 0.58) / descFontScale);
		
		double flavorTextLn = 14 + (2*descFontScale);
		double flavorTextHeight = flavorTextLines.Count() * (descFont.getHeight()+flavorTextLn);
		boxHeight += flavorTextLn * flavorTextLines.Count();
		
		// Move box up if too long
		if(pos.y + boxHeight > MWDrawer.GetBaseHeight())
			pos.y -= ((pos.y+boxHeight)-MWDrawer.GetBaseHeight()) + 60.0;

		Color itFntCol, itemColor;
		[itFntCol, itemColor] = MechItemSlot.GetItemColors(invItem);
		if(!itemColor) itemColor = 0xA07F7F7F;
		
		vector2 descPos = pos + (-310, 20);
		MWDrawer.Fill("Gray",  descPos.x,   descPos.y,    boxWidth,      boxHeight);
		MWDrawer.Fill("Black", descPos.x+3, descPos.y+3, boxWidth - 6, boxHeight - 6);
		
		double itemNameSize = boxWidth * 0.75;
		MWDrawer.Fill(itemColor, descPos.x + ((boxWidth - itemNameSize) * 0.5), descPos.y + 20., itemNameSize, 20);
		
		// Autofit display name
		Font itemNameFont = "hm_type";
		double itemNameScale = 1.0;
		double fitX = itemNameSize - 16;
		double itemNameWidth = itemNameFont.StringWidth(invItem.displayName) * itemNameScale * 2.0;
		double fitScale = itemNameWidth > fitX ? fitX / itemNameWidth : 1.0;
		
		// Text Shadow
		/*MWDrawer.DrawString("hm_type", invItem.displayName,
			(descPos.x+(boxWidth*0.5) + 2, descPos.y + descFont.getHeight() + 5), 
			MWDrawer.SS_TEXT_CENTER, Font.CR_BLACK, scale:(itemNameScale*fitScale, itemNameScale)
		);*/
		MWDrawer.DrawString(itemNameFont, invItem.displayName,
			(descPos.x+(boxWidth*0.5), descPos.y + descFont.getHeight() + 3), 
			MWDrawer.SS_TEXT_CENTER, Font.CR_WHITE, scale:(itemNameScale*fitScale, itemNameScale)
		);
		
		// Mount Type Icon
		let weapItem = MechWeapon(invItem);
		if(weapItem)
		{
			vector2 mountPos = ( descPos.x + 15, descPos.y + 15 );
			MWDrawer.Fill("Gray", descPos.x, descPos.y, 32,32, 1.0);
			
			double mountScale = 0.8; 
			
			string itemMountGraphic = HardpointMount.getMountGraphic(weapItem.mountType);
			if(itemMountGraphic) 
			{
				// Shadow
				MWDrawer.DrawImage(itemMountGraphic, mountPos + (4,4), alpha:0.65, scale:(mountScale,mountScale), tint:0xFF000000);
				
				// Base
				MWDrawer.DrawImage(itemMountGraphic, mountPos, scale:(mountScale,mountScale));
			}
		}
		
		// Flavor text
		vector2 flavorTextPos = (descPos.x+10, descPos.y + 50);
		double flavorTextMaxY = 0;
		for(int i = 0; i < flavorTextLines.Count(); i++)
		{
			string descLine = flavorTextLines.StringAt(i);
			MWDrawer.DrawString(
				flavorFont, descLine, 
				flavorTextPos,
				translation:Font.CR_GRAY, 1.0,
				scale:(descFontScale,descFontScale)*0.8
			);
			flavorTextPos.y += flavorTextLn;
		}
		
		// Stats
		vector2 lnPos = (descPos.x + 5, flavorTextPos.y + 20);
		for(int s = 0; s < itemStatName.Size(); s++)
		{
			string ln = itemStatName[s];
			string val = itemStatValue[s];
			MWDrawer.DrawString(
				descFont, ln, lnPos, translation:Font.CR_WHITE,
				scale:(descFontScale,descFontScale)
			);
			MWDrawer.DrawString(
				descFont, val, lnPos + (boxWidth-20, 0), flags:MWDrawer.SS_TEXT_RIGHT,
				translation:Font.CR_WHITE,
				scale:(descFontScale,descFontScale)
			);
			lnPos.y += (descFont.getHeight()*1.5*descFontScale) + descSpacing;
		}
	}
	
	override void Draw(double dT)
	{
		let inv = mechlab.inv;
		if(!inv) return;
		
		// Background
		Color edgeColor = 0xFF7A7A7A; //0xFF0074ea;
		MWDrawer.Fill(0xFF151515, pos.x,pos.y-20, size.x,size.y+40);
		MWDrawer.DrawRect(pos + (0,-20), size + (0,40), edgeColor);
		
		// Tab Background
		MWDrawer.Fill(0xFFAAAAAA, pos.x,pos.y-200, size.x,180);
		MWDrawer.DrawRect(pos + (0,-200), (size.x,180), edgeColor);
		
		// Scrollbar Background
		double xoffs = scrollBar.size.x * 0.35;
		double yoffs = 10;
		vector2 scrollBackgroundPos = (scrollBar.pos.x-xoffs, pos.y-yoffs+5);
		vector2 scrollBackgroundSize = (scrollBar.size.x * 1.7, size.y+yoffs);
		MWDrawer.Fill(0xFF000000, scrollBackgroundPos.x, scrollBackgroundPos.y, scrollBackgroundSize.x, scrollBackgroundSize.y);
		MWDrawer.DrawRect(
			(scrollBar.pos.x-xoffs, pos.y-yoffs+5), 
			(scrollBar.size.x * 1.7, size.y+yoffs), 
			edgeColor
		);
		
		bool scrollHover = AABBCollision(mechlab.cursor.pos, mechlab.cursor.size, scrollBackgroundPos, scrollBackgroundSize);
		
		double itemSpacing = 16;
		double startY = 20;
		double curY = (pos.y + startY) - scroll;
		bool doScrollTop = false; // If true, scrolls to the top of items list.
		
		Array<MechItem> filteredItems;
		bool skipItem;
		
		if(itemIndexes.Size() != inv.items.Size())
			itemIndexes.Resize(inv.items.Size());
			
		for(int i = 0; i < inv.items.Size(); i++)
		{
			let item = inv.items[i];
			if(!item) continue;
			
			// Skip hidden items
			if(item.hidden) continue;
			
			skipItem = false;
			
			if(itemSearch && MenuSearchBar.getSearchRelevancy(itemSearch, item.displayName) < 0.8)
				skipItem = true;
			
			if(!itemSearch)
			{
				bool anyActive = false;
				for(int x = 0; x < tabs.Size(); x++)
				{
					if(tabs[x].active) anyActive = true;
					if(tabs[x].doFilterItem(item)) 
						skipItem = true;
				}
				
				// Do not skip if no tabs are active.
				if(!anyActive) skipItem = false;
			}
			
			if(!skipItem) 
			{
				filteredItems.Push(item);
				itemIndexes[filteredItems.Size()-1] = i;
			}
		}
		
		// Update items list
		int curSize = invItems.Size();
		int newSize = filteredItems.Size();
		if(curSize != newSize)
		{
			if(newSize > curSize) doScrollTop = true;
			invItems.Resize(filteredItems.Size());
		}
		
		MWDrawer.SetClipRect(pos.x,pos.y,size.x,size.y);
		for(int i = 0; i < invItems.Size(); i++)
		{
			let item = invItems[i];
			if(!item)
			{	
				item = MechInvItem(MenuElement.Create(
					"MechInvItem", 
					String.Format("InvItem#%d",i), 
					parentMenu, pos + (size.x*0.30, 0), (size.x * 0.5, 16)
				));
				item.mechlab = mechlab;
				invItems[i] = item;
			}
			
			item.item = filteredItems[i];
			item.itemID = itemIndexes[i];
			
			bool dragging = mechlab.cursor.draggingElement == item;
			bool outOfBounds = !item.AABBCollision(pos, size, item.pos + (0, item.size.y * 0.5), (item.size.x, item.size.y * 0.25));
			item.outOfBounds = outOfBounds;
			
			if(!dragging)
			{
				item.pos.y = curY;			
				item.Draw(dT); // if(!outOfBounds) 
			}
			else
			{	
				// Redraw item but, grayed out.
				vector2 oldPos = item.pos;
				item.grayed = true;
				item.pos.x = item.defaultPos.x;
				item.pos.y = curY;
				item.Draw(dT);
				item.grayed = false;
				item.pos = oldPos;
			}
						
			// Needs to be called after Draw
			curY += (item.size.y + itemSpacing);
			
			if(!outOfBounds) item.Update(dT);
			
		}
		MWDrawer.ClearClipRect();
		
		// Dragging items
		let draggingHPItem = MechItemSlot(mechlab.cursor.draggingElement);
		let draggingInvItem = MechInvItem(mechlab.cursor.draggingElement);
		
		// Find scroll height
		double pageHeight = size.y;
		double maxY = pos.y + startY;
		for(int i = 0; i < invItems.Size(); i++)
		{
			let itemBox = invItems[i];
			if(!itemBox) continue;
			
			maxY += (itemBox.size.y + itemSpacing);
			bool hovering = mechlab.cursor.CheckCollision(itemBox);
		
			// Draw item stats if hovering over item.
			if(hovering && itemBox.item && !draggingInvItem && !itemBox.outOfBounds)
			{
				DrawItemStats(mechlab, itemBox.item, pos, size.x*0.75);
			}
		}
						
		// Scrollbar Element
		scrollBar.Update(dt);
		mechlab.cursor.CheckCollision(scrollBar);
		
		scrollMax = maxY - pageHeight - pos.y;
		scroll = scrollMax <= 0 ? 0 : clamp(scroll, 0, scrollMax);
		scrollBar.disabled = scrollMax <= 0;
		
		if(doScrollTop) scroll = 0;
		scrollBar.barSize = (size.y - scrollMax);
		if(mechlab.cursor.draggingElement != scrollBar)
		{
			scrollBar.Draw(dT);
			double scrollPerc = scroll / scrollMax;
			double toScrollY = pos.y + ( (size.y - scrollBar.size.y) * scrollPerc );
			scrollBar.pos.y = toScrollY;
						
			if(scrollHover && mechlab.cursor.leftDown)
			{
				double diff = (mechlab.cursor.pos.y - scrollBackgroundPos.y) / scrollBackgroundSize.y;
				scroll = diff * scrollMax;
			}
		}
		else
		{
			scroll = scrollBar.scrollPos * scrollMax;
		}
		
		if(mechlab.cursor.scrollDir > 0) scrollVel += (dT);
		if(mechlab.cursor.scrollDir < 0) scrollVel -= (dT);
		
		scroll += scrollVel;
		scrollVel *= 0.9;
		
		// Tabs
		for(int i = 0; i < tabs.Size(); i++)
		{
			let tab = tabs[i];
			
			tab.Draw(dT);
			tab.Update(dT);
		}
	}
}
class MechContainerScrollBar : MenuElement
{
	double scrollPos;
	double dragYOffs;
	double barSize;
	double maxY;
	
	virtual void Setup(MenuElement parentContainer)
	{
		self.parentElement = parentContainer;
	}
	
	override void OnDrag(MenuCursor cursor)
	{
		dragYOffs = cursor.pos.y - pos.y;
	}
	override bool checkDraggable()
	{
		return !disabled;
	}
	override void updateDragPos(MenuCursor cursor)
	{
		pos.y = cursor.pos.y - dragYOffs;
	}
	
	override void Draw(double dT)
	{
		if(!parentElement) return;
		double minSize = 24;
		barSize = clamp(barSize, minSize, parentElement.size.y);
		size.y  = barSize;
		
		maxY = (parentElement.pos.y+parentElement.size.y) - (size.y);
		pos.y = clamp(pos.y, parentElement.pos.y, maxY);

		double relY = (pos.y-parentElement.pos.y);
		scrollPos = relY / max(1, parentElement.size.y-size.y);
		
		if(!disabled)
		{
			MWDrawer.Fill("Gray", pos.x-2, pos.y-2, size.x+4, size.y+4);
			MWDrawer.Fill("White", pos.x , pos.y  , size.x, size.y);
		}
		else
		{
			MWDrawer.Fill("Black", pos.x-2, pos.y-2, size.x+4, size.y+4);
			MWDrawer.Fill("Gray", pos.x , pos.y  , size.x, size.y);
		}
	}
}
class InvContainerSearchBar : MenuSearchBar
{	
	MenuItemsInvContainer parentContainer;
	
	override void Init()
	{
		super.Init();
		parentContainer = MenuItemsInvContainer(parentElement);
	}
	
	override void OnSubmit()
	{
		if(parentContainer) 
			parentContainer.DoSearchFilter(buffer);
	}
}

class MechContainerTab : MenuButton
{
	string tabText;
	string tabIcon;
	vector2 iconScale;
	vector2 textScale;
	bool active;

	void Setup(string txt, string icon, vector2 iconScale = (1,1), vector2 textScale = (1,1))
	{
		self.tabText = txt;
		self.tabIcon = icon;
		self.iconScale = iconScale;
		self.textScale = textScale;
	}

	override void Draw(double dT)
	{
		Color bgColor = 0xFF111111;
		uint fontColor = Font.CR_WHITE;
		if(hovered) bgColor = 0xFF555555; //0xFF0A0A7A;
		if(active ) 
		{
			bgColor = 0xFFFFFFFF; //0xFF1C1CBC;
			fontColor = Font.CR_BLACK;
		}
		
		MWDrawer.Fill(bgColor, pos.x,pos.y, size.x,size.y);
		MWDrawer.DrawRect(pos, size, 0xFF7A7A7A);
		MWDrawer.SetClipRect(pos.x,pos.y, size.x,size.y);
		
		vector2 center = (
			pos.x + (size.x / 2.),
			pos.y + (size.y / 2.)
		);
		
		Font textFont = "bt_classic";
		double textHeight = textFont.getHeight() * (1.75*textScale.y);
		MWDrawer.DrawString(
			textFont, tabText, center - (0, textHeight*0.5), MWDrawer.SS_TEXT_CENTER,
			fontColor, scale:textScale
		);
		MWDrawer.DrawImage(tabIcon, center, scale:iconScale);
		
		MWDrawer.ClearClipRect();
	}
	
	override void OnPressed()
	{
		active = !active;
		pressed = false;
	}
}

class MechItemSortTab : MechContainerTab
{
	MenuItemsInvContainer parentContainer;
	class<MechItem> sortCls;
		
	override void Init()
	{
		super.Init();
		active = false;
	}
	
	override void Update(double dT)
	{
		super.Update(dT);
		
		// Tabs are not active while searching for all items.
		if(parentContainer && parentContainer.itemSearch != "")
			active = false;
	}
	
	// Return true to sort item out of list 
	virtual bool doFilterItem(MechItem item)
	{
		return (!active && (item is sortCls));
	}
	
	override void OnPressed()
	{
		super.OnPressed();
		foreach(tab : parentContainer.tabs)
		{
			if(tab == self) continue;
			tab.active = false;
		}
	}
}
class MechWeaponSortTab : MechItemSortTab
{
	string weapType;
	
	override void Init()
	{
		super.Init();
		active = true;
	}
	
	override bool doFilterItem(MechItem item)
	{
		let weap = MechWeapon(item);
		if(!weap) return false;
	
		return (!active && weap.mountType == weapType);
	}
}
class MechEquipmentSortTab : MechItemSortTab
{
	override bool doFilterItem(MechItem item)
	{
		bool filter = (item is "MechEngine") || (item is "MechUtility") || (item is "AMS");
		return (!active && filter);
	}
}
class MechRepairKitSortTab : MechItemSortTab
{
	override bool doFilterItem(MechItem item)
	{
		bool filter = (item is "MechRepairKit");
		return (!active && filter);
	}
}

class MechInvItem : MenuElement
{
	Mechmenu_Mechlab mechlab;
	MechItem item;
	int itemID;
	bool grayed;
	bool outOfBounds;
	bool dragging;
	bool locked;
	vector2 defaultPos;
	
	override void Init()
	{
		super.Init();
		defaultPos = pos;
	}
	
	override void Update(double dT)
	{
		// Disable hard-pointed items such as weapons, from being equipped while the mech is being piloted.
		locked = (mechlab.mech.driver && !(item is "MechAmmo"));
		
		// Keep repair kits enabled.
		if( (item is "MechRepairKit") && locked) locked = false;
	}
	
	override bool checkDraggable()
	{
		return !outOfBounds;
	}	
	override void updateDragPos(MenuCursor cursor)
	{
		pos = cursor.pos - (
			(size.x / 2.0) - (cursor.size.x / 2.0), 
			(size.y / 2.0) + 4
		);
		dragging = true;
	}
	
	override void OnDrop(MenuCursor cursor)
	{
		pos = defaultPos;
		dragging = false;
		
		if(locked) 
		{
			MDRDialogMenu.Open(mechlab, "Hardmount", "Only ammo can be equipped while mech is in active use.", "Continue");
			return;
		}
		
		let mouseOverContainer = MechHardpointContainer(cursor.getCollidingWithType("MechHardpointContainer"));	
		let mouseOverItem = mouseOverContainer ? mouseOverContainer.mouseHoverSlot : NULL; 

		// If dropped over item
		if(mouseOverItem && mouseOverItem.slotItem && item.addonCapable && cursor.checkCollision(mouseOverItem, false) && mechlab)
		{
			// hardpointID:itemID
			string destItemIDs = mechlab.mech.getMechItemIndex(mouseOverItem.slotItem);
			
			// Equip to Item
			EventHandler.SendNetworkEvent(String.Format("mechlab.item.addon.%s.%d", destItemIDs, itemID));
		}
		// If dropped into hardpoint
		else if(mouseOverContainer)
		{
			// Equip
			EventHandler.SendNetworkEvent(String.Format("mechlab.item.equip.%d.%d", itemID, mouseOverContainer.partID));
		}
	}
	
	override void Draw(double dT)
	{
		Font itemFont = "hm_type"; 
		bool destroyed = item.checkDestroyed();
		
		Color slotColor = 0;
		uint itemFontColor = Font.CR_WHITE;
		[itemFontColor, slotColor] = MechItemSlot.GetItemColors(item);
		if(destroyed)
		{
			itemFontColor = Font.CR_BLACK;
			slotColor = 0xFFFF0000;
		}
		if(grayed) 
		{
			itemFontColor = Font.CR_BLACK;
			slotColor = "Gray";
		}
		if(locked)
		{
			itemFontColor = Font.CR_GRAY;
			slotColor = 0xFF3F3F3F;
		}
		
		double scale = 0.5;
		double yscale = 1.1;
		double slotHeight = 32 * scale;
		double wScale = size.x / 256.0;
	
		int itemSize = item ? max(1,item.size) : 1;
		if(item is "MechEngine" && (!dragging || grayed) ) itemSize = 1;
		
		size.y = item ? slotHeight * itemSize * yscale : slotHeight;
		vector2 amtOffs = (size.x * 0.5, -(size.y*0.25));
		
		if(item)
		{	
			MWDrawer.DrawImage("Graphics/Mechlab/itemTop.png", pos, scale:(scale*wScale,scale*yscale), tint:slotColor, texoffs:(0,0));
			
			for(int i = 0; i < itemSize-1; i++)
			{
				MWDrawer.DrawImage(
					"Graphics/Mechlab/itemBottom.png", 
					pos + (0, slotHeight + (i * slotHeight*yscale)), 
					scale:(scale*wScale,scale*yscale), tint:slotColor, 
					texoffs:(0,0)
				);
			}
			
			// Draw item data
			double fontScale = wScale*1.0;
			vector2 centerPos = pos + (
				(size.x / 2.0),
				(size.y / 2.0) - ( (itemFont.GetHeight() * (2.0*fontScale) ) / 2.0 ) + 2
			);
			
			// Autofit 
			double fitX = size.x - 16;
			double itemNameWidth = itemFont.StringWidth(item.displayName) * fontScale * 2.0;
			double fitScale = itemNameWidth > fitX ? fitX / itemNameWidth : 1.0;
			
			MWDrawer.DrawString(
				itemFont, item.displayName, 
				centerPos, MWDrawer.SS_TEXT_CENTER, itemFontColor,
				scale:(fontScale * fitScale, fontScale)
			);
			
			// Quantity
			if( (!dragging || grayed) && !item.infinite )
			{
				int itemAmount = grayed ? item.amount - 1: item.amount; 
				MWDrawer.DrawString(
					itemFont, String.Format("%d x ", itemAmount), 
					centerPos - amtOffs, MWDrawer.SS_TEXT_RIGHT, Font.CR_WHITE,
					scale:(fontScale, fontScale)*1.2
				);
			}
		}
	}
}

class MechInfoContainer : MenuElement
{
	Mechmenu_Mechlab mechlab;
	DrivableMech mech;
	Array<MechlabUtilityButton> utils;
	
	override void Init()
	{
		super.Init();
		mechlab = Mechmenu_Mechlab(parentMenu);
		if(!mechlab) return;
		
		mech = mechlab.mech;
		
		vector2 utilButtonPos = (pos.x + 8, pos.y + size.y + 9);
		utilButtonPos.y += SetupUtilButtons("MechArmor_Standard", "MechArmor_Ferro", utilButtonPos);
		utilButtonPos.y += SetupUtilButtons("MechChassis_Standard", "MechChassis_Endosteel", utilButtonPos);
	}
		
	double SetupUtilButtons(class<MechItem> itemOne, class<MechItem> itemTwo, vector2 buttonPos)
	{
		// Util buttons
		vector2 utilButtonSize = (size.x * 0.45, size.x * 0.2);
	
		let utilItemOne = MechUtility(mechlab.inv.FindItem(itemOne));
		let utilItemTwo = MechUtility(mechlab.inv.FindItem(itemTwo));

		if(utilItemOne && utilItemTwo)
		{
			let utilOne = MechlabUtilityButton(
				MenuElement.Create("MechlabUtilityButton", "UtilButton1", parentMenu, buttonPos, utilButtonSize)
			);
			utilOne.Setup(mechlab, utilItemOne);
			buttonPos.x += utilButtonSize.x * 1.15;
			
			let utilTwo = MechlabUtilityButton(
				MenuElement.Create("MechlabUtilityButton", "UtilButton2", parentMenu, buttonPos, utilButtonSize)
			);
			utilTwo.Setup(mechlab, utilItemTwo);
			
			utils.Push(utilOne);
			utils.Push(utilTwo);
		}
		
		return utilButtonSize.y + 20;
	}
	
	override void Draw(double dT)
	{
		Color bgColor = 0xFF151515;
		Color edgeColor = 0xFF7A7A7A;
		MWDrawer.Fill(edgeColor, pos.x-2, pos.y-2, size.x+4, size.y+4);
		MWDrawer.Fill(bgColor, pos.x, pos.y, size.x, size.y);
		MWDrawer.Fill("Blue", pos.x+1, pos.y+1, size.x-2, 40);
		MWDrawer.Fill("DarkGray", pos.x, pos.y+42, size.x, 24);
		
		MWDrawer.Fill(edgeColor, pos.x-2, pos.y+size.y, size.x+4, 195);
		
		string mechName = mech.mechChassisName;
		string mechVariant = mech.mechVariantName;
		string mechTonnage = String.Format(
			"\c[%s] %.2f \c[White]/ %.1f", 
			(mech.maxWeight-mech.weight) < 1 ? "Red" : "White", 
			mech.weight, mech.maxWeight
		);
		
		uint curSlots, maxSlots;
		[curSlots, maxSlots] = mech.getSlotCount();
		
		string slots = String.Format(
			"\c[%s] %d \c[White]/ %d", 
			(maxSlots-curSlots) < 1 ? "Red" : "White", 
			curSlots, maxSlots
		);
		
		double textSize = 1.00;
		vector2 textPos = pos + (10,10);
		Font textFont = "bt_classic";
		
		MWDrawer.DrawString(textFont, mechName, pos + (size.x*0.5, 10), flags:MWDrawer.SS_TEXT_CENTER, scale:(textSize, textSize)*1.15);
		MWDrawer.DrawString(textFont, mechVariant, textPos + (1, 35), translation:Font.CR_BLACK, scale:(textSize, textSize));
		MWDrawer.DrawString(textFont, mechVariant, textPos + (0, 34), translation:Font.CR_SAPPHIRE, scale:(textSize, textSize));
		
		textPos.y += 100;
		MWDrawer.DrawString(textFont, "\c[Teal]Tonnage", textPos, scale:(textSize, textSize));
		MWDrawer.DrawString(textFont, mechTonnage, textPos + (size.x - 30, 20), flags:MWDrawer.SS_TEXT_RIGHT, scale:(textSize, textSize)*1.15);
		
		textPos.y += 70;
		MWDrawer.DrawString(textFont, "\c[Teal]Slots", textPos, scale:(textSize, textSize));
		MWDrawer.DrawString(textFont, slots, textPos + (size.x - 30, 20), flags:MWDrawer.SS_TEXT_RIGHT, scale:(textSize, textSize)*1.15);
		
		textPos.y += 80;
		MWDrawer.Fill(edgeColor, pos.x, textPos.y, size.x, 3);
		
		double engineSpeed = mech.engine ? mech.engine.getKPH(mech) : 0;
		MWDrawer.DrawString(textFont, 
			String.Format("\c[Teal]SPEED"), 
			textPos + (0,15), 
			scale:(textSize, textSize)
		);
		MWDrawer.DrawString(textFont, 
			String.Format("\c[White] %.1f / %.1f", engineSpeed, engineSpeed*0.5), 
			textPos + (size.x - 30, 15), flags:MWDrawer.SS_TEXT_RIGHT, 
			scale:(textSize, textSize)
		);
		
		textPos.y += 30;
		string engineType = mech.engine ? String.Format("\c[DarkGray]%s \c[White]%d", mech.engine.getTypeStr(), mech.engine.rating) : "NONE";
		MWDrawer.DrawString(textFont, 
			String.Format("\c[Teal]ENGINE"), 
			textPos + (0,15), 
			scale:(textSize, textSize)
		);
		MWDrawer.DrawString(textFont, 
			String.Format("\c[White]" .. engineType), 
			textPos + (size.x - 30, 15), flags:MWDrawer.SS_TEXT_RIGHT, 
			scale:(textSize, textSize)
		);
		
		textPos.y += 30;
		string armorRating = "0 / 0";
		if(mech.armorType)
		{
			int curArmor = mech.armorType.getArmorPoints(mech);
			int maxArmor = mech.armorType.getMaxArmorPoints(mech);
			armorRating = String.Format("\c[%s]%d / %d",
				curArmor == maxArmor ? "Green" : "White",
				curArmor,
				maxArmor
			);
		}
		
		MWDrawer.DrawString(textFont, 
			String.Format("\c[Teal]ARMOR"), 
			textPos + (0,15), 
			scale:(textSize, textSize)
		);
		MWDrawer.DrawString(textFont, 
			String.Format("\c[White]%s", armorRating), 
			textPos + (size.x - 30, 15), flags:MWDrawer.SS_TEXT_RIGHT, 
			scale:(textSize, textSize)
		);
		
		textPos.y += 50;
		double heatDissipation = 0;
		uint heatsinkCount;
		Array<MechItem> heatSinks;
		mech.FindAllItems("MechHeatsink", true, heatSinks);
		
		for(int i = 0; i < heatSinks.Size(); i++)
		{
			let hs = MechHeatsink(heatSinks[i]);
			if(!hs) continue;
			
			heatDissipation += (hs.heatEff * TICRATE);
			heatsinkCount++;
		}
		
		if(mech.engine)
		{
			for(int i = 0; i < mech.engine.heatsinks.Size(); i++)
			{
				heatDissipation += (mech.engine.heatsinks[i].heatEff * TICRATE);
				heatsinkCount++;
			}
		}
			
		MWDrawer.DrawString(textFont, 
			String.Format("\c[Teal]HEATSINKS"), 
			textPos + (0,15), 
			scale:(textSize, textSize)
		);
		MWDrawer.DrawString(textFont, 
			String.Format("\c[White]%d", heatsinkCount), 
			textPos + (size.x - 30, 15), flags:MWDrawer.SS_TEXT_RIGHT, 
			scale:(textSize, textSize)
		);
		
		textPos.y += 30;
		MWDrawer.DrawString(textFont, 
			String.Format("\c[Teal]HEATDISP"), 
			textPos + (0,15), 
			scale:(textSize, textSize)
		);
		MWDrawer.DrawString(textFont, 
			String.Format("\c[White]%.2f K/s", mech.BHUtoKelvin(heatDissipation)), 
			textPos + (size.x - 30, 15), flags:MWDrawer.SS_TEXT_RIGHT, 
			scale:(textSize, textSize)
		);
		
		textPos.y += 30;
		MWDrawer.DrawString(textFont, 
			String.Format("\c[Teal]HEATMAX"), 
			textPos + (0,15), 
			scale:(textSize, textSize)
		);
		MWDrawer.DrawString(textFont, 
			String.Format("\c[White]%.2f K", mech.maxKelvin), 
			textPos + (size.x - 30, 15), flags:MWDrawer.SS_TEXT_RIGHT, 
			scale:(textSize, textSize)
		);
		
		double heatGen = 0;
		double damageOut = 0;
		Array<MechItem> weapons;
		mech.FindAllItems("MechWeapon", true, weapons);
		for(int i = 0; i < weapons.Size(); i++)
		{
			let weap = MechWeapon(weapons[i]);
			if(!weap) continue;
			
			heatGen += (weap.heat * max(1,weap.refireCount));
			damageOut += weap.damage * max(1,weap.fireTime);
			
			let laserweap = SmallLaser(weap);
			if(laserweap) heatGen += laserweap.laserHeat * max(1,weap.fireTime);
			if(weap.projType) 
			{
				let defs = GetDefaultByType(weap.projType);
				damageOut += defs.truedamage * max(1,weap.refireCount);
			}
		}
		
		textPos.y += 50;
		MWDrawer.DrawString(textFont, 
			String.Format("\c[Teal]HEATGEN"), 
			textPos + (0,15), 
			scale:(textSize, textSize)
		);
		MWDrawer.DrawString(textFont, 
			String.Format("\c[White]%.2f K/s", mech.BHUtoKelvin(heatGen) / TICRATE), 
			textPos + (size.x - 30, 15), flags:MWDrawer.SS_TEXT_RIGHT, 
			scale:(textSize, textSize)
		);
		
		textPos.y += 30;
		MWDrawer.DrawString(textFont, 
			String.Format("\c[Teal]FIREPOWER"), 
			textPos + (0,15), 
			scale:(textSize, textSize)
		);
		MWDrawer.DrawString(textFont, 
			String.Format("\c[White]%.2f", damageOut * MechHardpoint.DMGSCALE), 
			textPos + (size.x - 90, 15), flags:MWDrawer.SS_TEXT_RIGHT, 
			scale:(textSize, textSize)
		);
		
		MWDrawer.DrawString(textFont, 
			String.Format("\c[DARKGRAY](%.2f)", damageOut), 
			textPos + (size.x - 30, 15), flags:MWDrawer.SS_TEXT_RIGHT,
			scale:(textSize, textSize)*0.7
		);
		
		// CBills
		textPos.y = pos.y + size.y - 60;
		string userCBills = MWDrawer.FormatNumber(mechlab.inv.cbills);
		MWDrawer.DrawString(textFont, 
			"\c[Teal]CBills", 
			textPos, scale:(textSize, textSize)
		);
		MWDrawer.DrawString(textFont, 
			String.Format("\c[White]%s", userCBills), 
			textPos + (size.x - 20, 0), flags:MWDrawer.SS_TEXT_RIGHT,
			scale:(textSize, textSize)*1.0
		);
		
		
		// Utility buttons
		if(utils.Size() >= 2)
		{
			int utilities = floor(utils.Size() / 2);
			TextureID boxTex = TexMan.CheckForTexture("Graphics/Mechlab/toggleBox.png");
			vector2 boxRes;
			[boxRes.x, boxRes.y] = TexMan.getSize(boxTex);
			vector2 boxScale = ((size.x*1.0) / boxRes.x, (size.x * 0.25) / boxRes.y);
			vector2 boxPos = (pos.x, pos.y) + (0, size.y);
			
			for(int i = 0; i < utils.Size(); i+=2)
			{
				let utilButtonOne = utils[i];
				let utilButtonTwo = utils[i+1];
				utilButtonOne.Update(dT);
				utilButtonTwo.Update(dT);
				utilButtonOne.Draw(dT);
				utilButtonTwo.Draw(dT);
				MWDrawer.DrawImage("Graphics/Mechlab/toggleBox.png", boxPos, scale:boxScale, texOffs:(0,0));
				boxPos.y += (boxRes.y * boxScale.y);
			}
		}
	}
}

// Buttons
class MechlabSquareButton : MenuButton
{
	string btnChar;
	
	virtual void Setup(string btnChar = "+")
	{
		self.btnChar = btnChar;
	}

	override void Draw(double dT)
	{
		double txtScale = size.x / 10.;
		vector2 charPos = pos + (0.5,-0.5);
	
		if(!btnDown && !disabled)
		{
			MWDrawer.DrawRect(pos, size + (2,2), "DarkGray");
			MWDrawer.Fill("White", pos.x,pos.y, size.x,size.y);
			MWDrawer.DrawString("bt_classic", btnChar, charPos - (0.5,2), translation:Font.CR_GRAY, scale:(txtScale,txtScale));
		}
		else
		{
			MWDrawer.DrawRect(pos, size + (2,2), "DarkGray");
			MWDrawer.Fill("White", pos.x,pos.y, size.x + 2,size.y + 2);
			MWDrawer.DrawString("bt_classic", btnChar, charPos - (1,1), translation:Font.CR_BLACK, scale:(txtScale,txtScale));
		}
	}
	
	override void Update(double dT)
	{
		super.Update(dT);
		
		if(heldTime > 5)
		{
			pressed = true;
			OnPressed();
			heldTime = 0;
		}
	}
}

// Utility button
class MechlabUtilityButton : MenuButton
{
	bool active;
	MechMenu_Mechlab mechlab;
	MechUtility util;

	virtual void Setup(MechMenu_Mechlab mechlab, MechUtility util)
	{
		self.util = util;
		self.mechlab = mechlab;
	}

	override void Draw(double dT)
	{
		active = util && util.isEquipped(mechlab.mech);
	
		double txtScale = 0.8;
		Color bgColor = "Black";
		uint fontColor = Font.CR_White;
		int drawFlags = MWDrawer.SS_NOASPECTCORRECTION | MWDrawer.SS_TEXT_CENTER;
		Font fnt = "bt_classic";
		
		if(hovered)
		{
			bgColor = "Gray";
			fontColor = Font.CR_Black;
			MenuItemsInvContainer.DrawItemStats(mechlab, util, (720,850), 350);
		}
		
		if(active)
		{
			bgColor = "Blue";
			fontColor = Font.CR_White;
		}
		
		MWDrawer.Fill(bgColor, pos.x,pos.y, size.x,size.y);
		vector2 strPos = (
			pos.x + (size.x * 0.5),
			pos.y + (size.y * 0.5) - (fnt.getHeight()*txtScale)
		);
		MWDrawer.DrawString(fnt, !util ? "UNKNOWN" : util.displayName, strPos, drawFlags, translation:fontColor, scale:(txtScale,txtScale));
	}
	
	override void OnPressed()
	{
		pressed = false;
		if(!mechlab) return;
		
		if(mechlab.mech.driver)
		{
			MDRDialogMenu.Open(mechlab, "Util.NoAccess", "Structure cannot be modified while mech is active.", "Continue");
			return;
		}
		
		int itemID = mechlab.inv.items.Find(util);
		double utilCost = util.getEquipmentCost(mechlab.mech);
		if(utilCost > 0)
		{
			string formatCost = MWDrawer.FormatNumber(utilCost);
			string msg = String.Format("This Item costs %s cbills to equip.\nPurchase and equip item?", formatCost);
			MDRDialogMenu.Open(mechlab, String.Format("Util.Confirm:%d", itemID), msg, "Yes", "No");
			return;
		}
		
		EventHandler.SendNetworkEvent(String.Format("mechlab.utility.activate.%d", itemID));
	}
}

// Mechlab Toolbox
// Strip Armor, Max Armor, Strip Equipment, Strip All
class MechlabToolbox : MenuElement
{
	double alpha;
	MechMenu_Mechlab base;
	MechToolButton stripArmor, maxArmor, stripItems, stripAll;
	
	
	override void Init()
	{
		alpha = 1.0;
		base = MechMenu_Mechlab(parentMenu);
		
		vector2 btnPos = pos + (18,28);
		vector2 btnSize = (256, 86) * 0.65;
		stripArmor = MechToolButton(AddChild(parentMenu, "MechToolButton", "Strip Armor", btnPos, btnSize));
		maxArmor = MechToolButton(AddChild(parentMenu, "MechToolButton", "Max Armor", btnPos + (200,0), btnSize));
		stripItems = MechToolButton(AddChild(parentMenu, "MechToolButton", "Strip Items", btnPos + (0,80), btnSize));
		stripAll = MechToolButton(AddChild(parentMenu, "MechToolButton", "Strip All", btnPos + (200,80), btnSize));
	}
	
	override void Draw(double dT)
	{
		MWDrawer.Fill(0xFF7F7F7F, pos.x - 2, pos.y - 2, size.x + 4, size.y + 4);
		MWDrawer.Fill(0xFF4F4F4F, pos.x, pos.y, size.x, size.y);
	}
	
	override void Update(double dT)
	{
		let mech = base.mech;
		string cmd = "";
		bool mechIsActive = base.mech.driver;
			
		if(stripArmor.pressed)
		{
			stripArmor.pressed = false;
			if(mechIsActive)
			{
				MDRDialogMenu.Open(base, "Util.NoAccess", "Armor cannot be modified while mech is active.", "Continue");
				return;
			}
		
			cmd = String.Format("mechlab.striparmor.%d", mech.saveID);
		}
		if(maxArmor.pressed)
		{
			maxArmor.pressed = false;
			if(mechIsActive)
			{
				MDRDialogMenu.Open(base, "Util.NoAccess", "Armor cannot be modified while mech is active.", "Continue");
				return;
			}
		
			// Check weight
			if(!mech.armorType) return;
			
			double curArmorWeight = mech.armorType.getArmorPoints(mech) * mech.armorType.armorWeight;
			double maxArmorWeight = mech.armorType.getMaxArmorPoints(mech) * mech.armorType.armorWeight;
			double weightDiff = maxArmorWeight - curArmorWeight;
			if( (mech.weight + weightDiff) > mech.maxWeight )
			{
				MDRDialogMenu.Open(base, "armorweighterr", "Maximizing this mech's armor would exceed chassis maximum supported weight.", "Continue");
				return;
			}
		
			cmd = String.Format("mechlab.maxarmor.%d", mech.saveID);
		}
		if(stripItems.pressed)
		{
			stripItems.pressed = false;
			if(mechIsActive)
			{
				MDRDialogMenu.Open(base, "Util.NoAccess", "Equipment cannot be modified while mech is active.", "Continue");
				return;
			}
		
			cmd = String.Format("mechlab.stripitems.%d", mech.saveID);
		}
		if(stripAll.pressed)
		{
			stripAll.pressed = false;
			if(mechIsActive)
			{
				MDRDialogMenu.Open(base, "Util.NoAccess", "Equipment cannot be modified while mech is active.", "Continue");
				return;
			}
		
			cmd = String.Format("mechlab.stripall.%d", mech.saveID);
		}
		
		if(cmd != "") EventHandler.SendNetworkEvent(cmd);
	}
}

class MechToolButton : MenuButton
{
	override void Draw(double dT)
	{
		string btnGraphic = "Graphics/Mechlab/rounded_button.png";
		vector2 gScale = ScaleGraphicToCollider(btnGraphic);
		
		Color tint = pressed ? 0xC6111bd4 : 0;
		if(hovered) tint = 0xC63b3e80;
		
		MWDrawer.DrawImage(btnGraphic, pos + (size * 0.5), scale:gScale, tint:tint);
		
		Font fnt = "hm_type";
		double txtScale = 0.65;
		vector2 txtOffs = (0,10);
		MWDrawer.DrawString(fnt, Tag, pos + (size * 0.5) - txtOffs, flags:MWDrawer.SS_TEXT_CENTER, scale:(txtScale, txtScale));
	}
}

// Mechlab Menu
class MechMenu_Mechlab : MechMenu 
{
	I_MechItemStorage inv;
	MechLabCursor cursor;
	DrivableMech mech;
	Actor invSource;
	
	override void InitElements() 
	{
		elements.Clear(); // Repopulate elements
		// Get active mech.
		/*
		let drvObj = I_DrivingObject.Get(players[consoleplayer].mo);
		if(drvObj && drvObj.source) mech = DrivableMech(drvObj.source);
		*/
		
		if(!mech || !invSource) return;
		inv = I_MechItemStorage(invSource.FindInventory("I_MechItemStorage"));
	
		vector2 hpSlotsPos = (840,325);
		double slotsWidth = 196;
		double spacing = 205;
		
		// Mech info screen
		AddElement("MechInfoContainer", "MechInfoScreen", (15,25), (380,850));
	
		// Head
		let headSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_HD", hpSlotsPos - (0,25), (slotsWidth,256))
		);
		headSlots.Setup("Head", mech.head, slotsWidth, 34);
	
		// Arms
		let leftArmSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_LA", hpSlotsPos - (spacing*2, -50), (slotsWidth,256))
		);
		leftArmSlots.Setup("Left Arm", mech.leftArm, slotsWidth, 34);
		
		let rightArmSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_RA", hpSlotsPos + (spacing*2, 50), (slotsWidth,256))
		);
		rightArmSlots.Setup("Right Arm", mech.rightArm, slotsWidth, 34);
		
		// Torso(s)
		let leftTorsoSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_LT", hpSlotsPos - (spacing,0), (slotsWidth,256))
		);
		leftTorsoSlots.Setup("Left Torso", mech.leftTorso, slotsWidth, 34);
		
		let centerTorsoSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_CT", hpSlotsPos + (0,230), (slotsWidth,256))
		);
		centerTorsoSlots.Setup("Center Torso", mech.torso, slotsWidth, 34);
		
		let rightTorsoSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_RT", hpSlotsPos + (spacing,0), (slotsWidth,256))
		);
		rightTorsoSlots.Setup("Right Torso", mech.rightTorso, slotsWidth, 34);
		
		// Legs
		let leftLegSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_LL", hpSlotsPos + (-spacing, 355), (slotsWidth,256))
		);
		leftLegSlots.Setup("Left Leg", mech.leftLeg, slotsWidth, 34);
		
		let rightLegSlots = MechHardpointContainer(
			AddElement("MechHardpointContainer", "Hardpoint_RL", hpSlotsPos + (spacing,355), (slotsWidth,256))
		);
		rightLegSlots.Setup("Right Leg", mech.rightLeg, slotsWidth, 34);
		
		// Items inventory
		AddElement("MenuItemsInvContainer", "InventoryContainer", (1480,250), (400,600));
		
		// Toolbox
		AddElement("MechlabToolbox", "Toolbox", (1481,872), (398, 200));
		
		// Cursor is added last, to keep always on-top.
		cursor = MechLabCursor(AddElement("MechLabCursor", "Cursor", (0,0), (10,10))); 
		
	}
	
	override void Drawer()
	{
		super.Drawer();
		
		// Mech must be shutdown to use the mechlab to reload.
		if(mech && mech.driver && !mech.shutdown)
		{
			MWDrawer.Fill(0xFF0F0F0F, 0, 0, MWDrawer.getBaseWidth(), MWDrawer.getBaseHeight(), 0.60);
			if(!pauseUpdates) MDRDialogMenu.Open(self, "Mechlab.NoAccess", "Mech must be shutdown prior to accessing the mechlab.", "Exit Mechlab");
			pauseUpdates = true;
		}
	}
	
	override void OnMenuClose()
	{
		// Save mech on exit.
		if(!mech) return;
		
		string cmd = String.Format("mechlab.savemech.%d", mech.saveID-1);
		EventHandler.SendNetworkEvent(cmd);
		EventHandler.SendNetworkEvent("mw_status_closedmechlab");
	}
	
	play static void SendItemErrorMessage(int playerNumber, MechItem item, int ERR)
	{
		String errorMessage = item.GetItemErrorMessage(ERR);
		EventHandler.SendInterfaceEvent(playerNumber, String.Format("item.error.%s", errorMessage));
	}
	
	play static void processMechlabEvents(ConsoleEvent e, DrivableMech mech)
	{
		// Menu events
		let plr = players[e.Player].mo;
		let inv = I_MechItemStorage.Get(plr);
		let playerMechs = I_SaveMechData(plr.FindInventory("I_SaveMechData"));
			
		if(!mech) return;
		
		string menuCmd = e.Name;
		Array<String> menuArgs;
		menuCmd.Split(menuArgs, ".");
		
		Array<String> dialogInfo;
		menuCmd.Split(dialogInfo, ":");
		
		uint argc = menuArgs.Size();
		if(!argc) return;
		
		if(dialogInfo[0] ~== "dialog")
		{
			if(dialogInfo[1] ~== "Mechlab.NoAccess")
			{
				// Process to close mechlab.
				EventHandler.SendInterfaceEvent(e.Player, "mechlab.forceclose");
			}
			
			if(dialogInfo[1] ~== "Util.Confirm")
			{
				int utilID = dialogInfo[2].ToInt();
				if( !(dialogInfo[3] ~== "yes") ) return; // User declined purchase.
				
				let toHardpoint = MechHardpoint(mech.torso);
				if(!toHardpoint) return;

				let item = inv.items[utilID];
				int success = item.TryAttach(toHardpoint);
				if(success != MechItem.IAE_SUCCESS) 
					SendItemErrorMessage(e.Player, item, success);
			}
		}
		
		if(menuArgs[0] ~== "mechlab")
		{
			if(menuArgs[1] ~== "savemech" && playerMechs)
			{
				int mechIndex = menuArgs[2].ToInt();
				console.printf("Saving mech: %d", mechIndex);
				let mechlabMech = playerMechs.mechsData[mechIndex];
				if(mechlabMech && mechlabMech.mechobj)
				{
					playerMechs.SaveMechData(mechlabMech.mechobj);
					playerMechs.ReloadMechbay(mechlabMech.mechbayID);
				}
			}
		
			if(menuArgs[1] ~== "armor")
			{
				let srcHardpoint = MechHardpoint(mech.parts[menuArgs[4].ToInt()]);
				double amt = menuArgs[5].ToInt();
				
				bool front = menuArgs[2] ~== "front";
				bool rear = menuArgs[2] ~== "rear";
				
				if(menuArgs[3] ~== "add")
					srcHardpoint.adjustArmor(front ? amt : 0, rear ? amt : 0);
				
				if(menuArgs[3] ~== "remove")
					srcHardpoint.adjustArmor(front ? -amt : 0, rear ? -amt : 0);		
			}
			
			if(menuArgs[1] ~== "maxarmor")
			{
				let mechID = menuArgs[2].ToInt();
				let mech = playerMechs.mechsData[mechID-1].mechobj;
				
				Array<MechHardpoint> hardpoints;
				mech.getHardpoints(hardpoints, skipDestroyed:false);	
				foreach(hp : hardpoints)
				{
					double maxFrontArmor = hp.maxArmor - hp.maxRearArmor;
					double maxRearArmor = hp.maxRearArmor;
					hp.adjustArmor(maxFrontArmor, maxRearArmor);
				}		
			}
			if(menuArgs[1] ~== "striparmor" || menuArgs[1] ~== "stripall")
			{
				let mechID = menuArgs[2].ToInt();
				let mech = playerMechs.mechsData[mechID-1].mechobj;
				
				Array<MechHardpoint> hardpoints;
				mech.getHardpoints(hardpoints, skipDestroyed:false);	
				foreach(hp : hardpoints)
				{
					hp.armorPoints = 0;
					hp.rearArmor = 0;
				}		
			}
			if(menuArgs[1] ~== "stripitems" || menuArgs[1] ~== "stripall")
			{
				let mechID = menuArgs[2].ToInt();
				let mech = playerMechs.mechsData[mechID-1].mechobj;
				
				Array<MechHardpoint> hardpoints;
				mech.getHardpoints(hardpoints, skipDestroyed:false);	
				foreach(hp : hardpoints)
				{
					for(int itemID = hp.items.Size()-1; itemID >= 0; itemID--)
					{
						let srcItem = hp.items[itemID];
						if(!srcItem) return;
					
						if(srcItem.TryDetach()) 
							inv.AddItem(srcItem);
					}
				}		
			}
			
			if(menuArgs[1] ~== "utility")
			{
				if(menuArgs[2] ~== "activate")
				{
					int itemID = menuArgs[3].ToInt();
					
					let toHardpoint = MechHardpoint(mech.torso);
					if(!toHardpoint) return;

					let item = inv.items[itemID];
					int success = item.TryAttach(toHardpoint);
					if(success != MechItem.IAE_SUCCESS) 
						SendItemErrorMessage(e.Player, item, success);
				}
			}
			
			if(menuArgs[1] ~== "item")
			{	
				string indexArgs = menuArgs[3];
				Array<String> indices;
				indexArgs.Split(indices, ":");
				int partID, itemID;
				if(indices.Size() >= 2)
				{
					partID = indices[0].ToInt();
					itemID = indices[1].ToInt();
				}
			
				if(menuArgs[2] ~== "addon")
				{					
					let invItem = inv.items[menuArgs[4].toInt()];
					let destItem = MechHardpoint(mech.parts[partID]).items[itemID];
					
					invItem.OnAddon(destItem);
					destItem.ApplyAddon(invItem);
				}
			
				if(menuArgs[2] ~== "equip") 
				{
					int toHardpointID = menuArgs[4].toInt();
					int itemID = menuArgs[3].ToInt();
					
					let toHardpoint = MechHardpoint(mech.parts[toHardpointID]);
					if(!toHardpoint) return;
					
					let item = inv.takeItem(itemID, deplete:false);
					if(!item) return;

					int success = item.TryAttach(toHardpoint);
					if(success == MechItem.IAE_SUCCESS) 
						inv.depleteItem(inv.items[itemID]);
					else
						SendItemErrorMessage(e.Player, item, success);
						
					return;
				}								
				if(menuArgs[2] ~== "move") 
				{
					let srcHardpoint = MechHardpoint(mech.parts[partID]);
					let srcItem = srcHardpoint.items[itemID];
					if(!srcItem) return;
					
					int toHardpointID = menuArgs[4].toInt();
					let toHardpoint = MechHardpoint(mech.parts[toHardpointID]);
					
					if(srcItem.TryDetach())
					{
						int success = srcItem.TryAttach(toHardpoint);		
						if(success != MechItem.IAE_SUCCESS)
						{
							srcItem.TryAttach(srcHardpoint);
							SendItemErrorMessage(e.Player, srcItem, success);
						}
					}
				}
				if(menuArgs[2] ~== "dequip") 
				{
					let srcItem = MechHardpoint(mech.parts[partID]).items[itemID];
					if(!srcItem) return;
					
					if(srcItem.TryDetach()) 
						inv.AddItem(srcItem);
				}
			}
		}
	}
	
	override void processPlayEvent(int playerNumber, string event) 
	{
		Array<String> cmds;
		event.Split(cmds, ".");
		
		let plr = players[playerNumber].mo;
		if(cmds[0] == "mechlab")
		{		
			if(cmds[1] == 'update')
			{
				let mechEvents = MechInteraction_Handler(EventHandler.Find("MechInteraction_Handler"));
				if(!mechEvents) return;
			
				invSource = plr;
				mech = mechEvents.mechlab_curmech[playerNumber];
				InitElements();
			}
			
			if(cmds[1] == "forceclose")
			{
				// We shouldn't need to save the mech when no changes have been made.
				// OnMenuClose(); 
				
				Close();
			}
		}
		
		if(cmds.Size() >= 3)
		{
			if(cmds[0] == "item")
			{
				if(cmds[1] == "error")
				{
					MDRDialogMenu.Open(self, "ItemError", String.Format("\c[Brick]Failed to Equip Item\n\c[Gray]Reason: %s", cmds[2]), "Continue");
					// console.printf("ERROR: %s", cmds[2]);
				}
			}
		}
	}
	
	override void OnElementEvent(MenuElement source, string eventType, int intArg, double doubleArg, Object objArg)
	{
		// MenuElements can call this function if they wish to relay behavior to their parent menu.
	}
}
