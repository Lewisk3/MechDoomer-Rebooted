
class ShopItemsContainer : MenuElement
{
	enum ListingModes
	{
		LIST_WEAPONS = 0,
		LIST_MECHS 	 = 1,
		LIST_UTILITIES = 2,
		LIST_ENGINES = 3
	};
		
	int listingMode;
	int containerType;

	ShopMenu base;
	double alpha;
	
	double scroll, scrollVel;
	double listHeight; // Maximum height of items stored in list.
	Array<MechItem> items;
	Array<class<DrivableMech> > mechs;
	ShopScrollBar scrollBar;
	
	override void Init()
	{	
		super.Init();
		
		alpha = 1.0;
		base = ShopMenu(parentMenu);
		listingMode = LIST_WEAPONS;
		
		vector2 scrollBarPos = pos + (size.x - 40, 0);
		scrollBar = ShopScrollBar(AddChild(base, "ShopScrollBar","ScrollBar", scrollBarPos));
		scrollBar.size.x = 40;
	}
	
	virtual void Setup(out Array<MechItem> items, out Array<class<DrivableMech> > mechs, int containerType)
	{
		if(items) self.items.Copy(items);
		if(mechs) self.mechs.Copy(mechs);
		self.containerType = containerType;
		populateChildren();
	}
	
	void populateChildren()
	{
		ClearChildren(base, "ShopItem");
		int itemY = 0;
		int itemIndex = 0;
		listHeight = 0;	
		
		// Populate based on items list.		
		int limit = 1000;
		if(items.Size() > 0 && listingMode != LIST_MECHS)
		{
			foreach(item : items)
			{
				bool skipItem = false;
				switch(listingMode)
				{
					case LIST_WEAPONS: 
						skipItem = !(item is "MechWeapon" || item is "MechAmmo"); 
					break;
					
					case LIST_UTILITIES: 
						skipItem = !(item is "MechUtility" || item is "AMS" || item is "MechRepairKit"); 
					break;
					
					case LIST_ENGINES:
						skipItem = !(item is "MechEngine");
					break;
				}
				
				// Check if item source is in the cart, if so, skip it.
				foreach(cartItem : base.shopCart)
				{	
					if(cartItem.objItem == item)
					{
						skipItem = true;
						break;
					}
				}
				
				if(skipItem) continue;
				
				if(item.size > 0)
				{
					let cItem = ShopItem(AddChild(base, "ShopItem", "ShopContainerItem", pos + (30,20 + itemY)));
					cItem.objItem = item;
					cItem.count = item.amount;
					cItem.Update(0);
					if(containerType == ShopMenu.SHOP_BUYING)
						cItem.infinite = true;
					
					itemY += cItem.size.y + 30;
					itemIndex++;
				}
				if(itemIndex > limit) break;
			}
			listHeight = -(itemY - size.y);
			if(listHeight > 0) listHeight = 0;
		}
	}
	
	void ChangeListing(int mode)
	{
		listingMode = mode;
		populateChildren();
	}
	
	override void Draw(double dt)
	{
		int drawFlags = MWDrawer.SS_NOASPECTCORRECTION;
		
		MWDrawer.Fill(0x7F7F7F, pos.x - 4, pos.y - 4, size.x + 8, size.y + 8, alpha, drawFlags);
		MWDrawer.Fill(0x1F1F1F, pos.x, pos.y, size.x, size.y, alpha, drawFlags);
	
		vector2 tabPos = pos + (0,-170);
		MWDrawer.Fill(0x7F7F7F, tabPos.x-4, tabPos.y, size.x + 8, 170);
		MWDrawer.Fill(0x3F3F3F, tabPos.x-4, tabPos.y, size.x + 8, 64);
	
		double tabWidth = (size.x*0.9) / 4.0;
		DrawTab("\c[White]Weapons", tabPos, (tabWidth,64), listingMode == LIST_WEAPONS);
		tabPos.x += tabWidth + 16;
		DrawTab("\c[White]Utilities", tabPos, (tabWidth,64), listingMode == LIST_UTILITIES);
		tabPos.x += tabWidth + 16;
		DrawTab("\c[White]Engines", tabPos, (tabWidth,64), listingMode == LIST_ENGINES);
		tabPos.x += tabWidth + 16;
		DrawTab("\c[White]Mechs", tabPos, (tabWidth,64), listingMode == LIST_MECHS);
	}
	
	void DrawTab(String txt, vector2 tabPos, vector2 tabSize, bool active = false)
	{
		Color outlineColor = 0x3F3F3F;
		Color bgColor = 0x5F5F5F;
		if(active) outlineColor = bgColor = 0x7F7F7F;
		
		MWDrawer.Fill(outlineColor, tabPos.x - 4, tabPos.y - 4, tabSize.x + 8, tabSize.y + 8);
		MWDrawer.Fill(bgColor, tabPos.x, tabPos.y, tabSize.x, tabSize.y);
	
		vector2 txtPos = tabPos + (tabSize.x * 0.5,tabSize.y * 0.5);
		txtPos.y -= MWDrawer.GetTextHeight("SmallFont", txt) * 0.5;
		MWDrawer.DrawString("SmallFont", txt, txtPos, MWDrawer.SS_TEXT_CENTER);
	}
	
	override void Update(double dT)
	{
		disabled = !(base.shopMode == ShopMenu.SHOP_NEUTRAL || base.shopMode == containerType);
		
		// Update Item scroll position.
		foreach(child : children)
		{
			let shopItm = ShopItem(child);
			if(!shopItm) continue;
			
			// Update scroll
			shopItm.posOffs.y = -scrollBar.curScroll;
		}
	
		scroll = -scrollBar.curScroll;
		scrollBar.itemListHeight = abs(listHeight);
		
		if(CheckCollision(base.cursor, false) && base.cursor.scrollDir != 0)
				scrollVel += (1 * base.cursor.scrollDir * dT);
				
		scrollVel *= 0.96;
		scrollBar.scrollTo += scrollVel;
		
		/* Debug
		if(base.cursor.rightPressed && CheckCollision(base.cursor, false)) 
		{
			listingMode = (listingMode + 1) % 4;
			ChangeListing(listingMode);
			console.printf("Listing mode %d", listingMode);
		}
		*/
	}
}

class CartContainer : MenuElement
{
	ShopMenu base;
	double alpha;
	ShopScrollBar scrollBar;
	double scrollVel;

	override void Init()
	{	
		super.Init();
		
		alpha = 1.0;
		base = ShopMenu(parentMenu);
		
		vector2 scrollBarPos = pos + (size.x - 40, 0);
		scrollBar = ShopScrollBar(AddChild(base, "ShopScrollBar","ScrollBar", scrollBarPos));
		scrollBar.size.x = 40;
	}
	
	override void Draw(double dT)
	{
		int drawFlags = MWDrawer.SS_NOASPECTCORRECTION;

		MWDrawer.Fill(0x7F7F7F, pos.x - 4, pos.y - 4, size.x + 8, size.y + 8, alpha, drawFlags);
		MWDrawer.Fill(0x1F1F1F, pos.x, pos.y, size.x, size.y, alpha, drawFlags);
		
		// Draw transaction box
		vector2 trBoxPos = (pos.x, pos.y + size.y + 20);
		
		MWDrawer.Fill(0x7F7F7F, pos.x - 4, (pos.y - 4) + size.y + 4, size.x + 8, 124);
		MWDrawer.Fill(0x101010, trBoxPos.x, trBoxPos.y, size.x, 100);
		
		MWDrawer.DrawString("SmallFont", "\c[Gray]Transaction Cost", trBoxPos + (size.x * 0.5,12), MWDrawer.SS_TEXT_CENTER);
		
		string sellingColor = "\c[Green] +";
		string buyingColor = "\c[Red] -";
		string colStr;
		
		Color leftColor = 0xFF000000;
		Color rightColor = 0xFF000000;
		
		switch (base.shopMode)
		{
			case ShopMenu.SHOP_BUYING:
				colStr = buyingColor;
				leftColor = 0;
				rightColor = 0xFF000000;
			break;
			case ShopMenu.SHOP_SELLING:
				colStr = sellingColor;
				rightColor = 0;
				leftColor = 0xFF000000;
			break;
		}
		
		double cost = getTransactionCBills();
		string price = String.Format("%s%s", colStr, MWDrawer.FormatNumber(abs(cost)));
		MWDrawer.DrawString("SmallFont", price, trBoxPos + (size.x * 0.5,45), MWDrawer.SS_TEXT_CENTER);
		
		double balance = base.PlayerItems.cbills + cost;
		string balString = String.Format("\c[Gray]%s\c[White]", MWDrawer.FormatNumber(balance));
		if(balance < 0) balString = String.Format("\c[Red]%d\c[White]", balance);
		MWDrawer.DrawString("SmallFont", "\c[White]= " .. balString, trBoxPos + (size.x * 0.5,65), MWDrawer.SS_TEXT_CENTER);
		
		// CBill Icons
		double priceWidth = MWDrawer.GetTextWidth("SmallFont", price);
		MWDrawer.DrawImage("Graphics/Shop/CBill_Icon.png", trBoxPos + ( 12 + (size.x * 0.5) + (priceWidth * 0.5), 6 + 45), scale:(0.8,0.8));
		
		// Direction arrow
		vector2 arrowPos = pos + (-50,size.y * 0.5);

		// Left
		MWDrawer.DrawImage("Graphics/Shop/ShopDirection.png", arrowPos, scale:(0.3,0.3), tint:leftColor);
		
		// Right
		MWDrawer.DrawImage("Graphics/Shop/ShopDirection.png", arrowPos + (0,30), scale:(-0.3,0.3), tint:rightColor);
		
		// Account box
		vector2 acBoxPos = (pos.x, pos.y - 120);
		
		MWDrawer.Fill(0x7F7F7F, acBoxPos.x - 4, acBoxPos.y - 4, size.x + 8, 120);
		MWDrawer.Fill(0x101010, acBoxPos.x, acBoxPos.y, size.x, 100);
		
		MWDrawer.DrawString("SmallFont", "\c[Gray]Account Balance", acBoxPos + (size.x * 0.5,12), MWDrawer.SS_TEXT_CENTER);
		String accBalanceStr = String.Format("\c[White]%s", MWDrawer.FormatNumber(base.PlayerItems.cbills)); 
		MWDrawer.DrawString("SmallFont", accBalanceStr, acBoxPos + (size.x * 0.5,50), MWDrawer.SS_TEXT_CENTER);
		double balanceWidth = MWDrawer.GetTextWidth("SmallFont", accBalanceStr);
		MWDrawer.DrawImage("Graphics/Shop/CBill_Icon.png", acBoxPos + ( 12 + (size.x * 0.5) + (balanceWidth * 0.5), 6 + 50), scale:(0.8,0.8));
	}
	
	double getTransactionCBills()
	{
		double cost = 0;
		foreach(item : base.shopCart)
		{
			if(item.objItem) 
				cost += item.objItem.value * item.count;
		}
		
		switch (base.shopMode)
		{
			case ShopMenu.SHOP_BUYING:
				cost = -cost;
			break;
			case ShopMenu.SHOP_SELLING:
				cost *= 0.5;
			break;
		}
		
		return cost;
	}
	
	virtual void ClearCart()
	{
		foreach(item : base.shopCart)
			RemoveFromCart(item, item.count);
	}
	
	virtual void RemoveFromCart(ShopItem shopItm, double amt = 1)
	{		
		int cartItemIndex;
		ShopItem cartItem = NULL;
		foreach(item : base.shopCart)
		{
			cartItemIndex++;
			if(item.IsSameitem(shopItm))
			{
				cartItem = item;
				break;
			}
		}
		if(!cartItem) return;
		
		if(shopItm.objItem)
		{
			cartItem.count-=amt;
			// Restore count to old item
			foreach(menuItem : base.elements)
			{
				let sItem = ShopItem(menuItem);
				if(sItem && sItem.objItem == shopItm.objItem)
				{
					sItem.count+=amt;
					break;
				}
			}
			
			if(cartItem.count <= 0)
			{
				base.shopCart.Delete(cartItemIndex-1);
				RemoveChild(shopItm);
			}
		}
		else if(shopItm.clsMech)
		{
			// Add mech to cart.
		}
		
		if(base.shopCart.Size() <= 0)
			base.shopMode = ShopMenu.SHOP_NEUTRAL;
	}
	
	virtual void AddToCart(ShopItem shopItm)
	{
		// Grab item container
		let itemContainer = ShopItemsContainer(shopItm.parentElement);
		if(!itemContainer) return;
		
		if( !(base.shopMode == ShopMenu.SHOP_NEUTRAL || itemContainer.containerType == base.shopMode) )
			return; // Invalid item for current shopping mode.
		
		// Update shop mode to container type.
		base.shopMode = itemContainer.containerType;
		
		ShopItem cartItem = NULL;
		foreach(item : base.shopCart)
		{
			if(item.IsSameItem(shopItm))
			{
				cartItem = item;
				break;
			}
		}
		
		if(shopItm.objItem)
		{
			// Add child shopItem to container if not already present in the shopping cart.
			if(!cartItem)
			{
				let cartMenuItem = ShopItem(AddChild(base, "ShopItem", "CartItem", pos));
				cartMenuItem.objItem = shopItm.objItem;
				cartMenuItem.count = 1;
				cartMenuItem.Update(0);
				cartMenuItem.inCart = true;
								
				base.shopCart.push(cartMenuItem);
			}
			else cartItem.count++;
			shopItm.count--;
		}
		else if(shopItm.clsMech)
		{
			// Add mech to cart.
		}
	}
	
	override void Update(double dT)
	{
		// Get list height from shopping cart.
		// Update positions
		double listHeight = 0;
		int itemY = 0;
		foreach(item : base.shopCart)
		{
			item.posOffs = (10, 5 + itemY - scrollBar.curScroll);
			itemY += item.size.y + 30;
		}
		listHeight = -(itemY - size.y);
		if(listHeight > 0) listHeight = 0;
		scrollBar.itemListHeight = abs(listHeight);
		
		if(CheckCollision(base.cursor, false) && base.cursor.scrollDir != 0)
			scrollVel += (1 * base.cursor.scrollDir * dT);
				
		scrollVel *= 0.96;
		scrollBar.scrollTo += scrollVel;
		
		if(base.shopCart.Size() <= 0)
			base.shopMode = ShopMenu.SHOP_NEUTRAL;
	}
}

class ShopItem : MenuElement
{
	// These should be treated as a union, items can either be MechItems, or a mech class.
	MechItem objItem;
	class<DrivableMech> clsMech;
	int mechbayItem; // Used for selling mechs.
	ShopMenu base;
	bool dragging;
	vector2 posOffs;
	int count;
	bool infinite;
	bool inCart;
	
	virtual bool IsSameItem(ShopItem other)
	{
		bool sameMech = clsMech && (clsMech == other.clsMech && mechbayItem == other.mechbayItem);
		return objItem == other.objItem || sameMech;
	}
	
	override void Init()
	{
		size = (256,128);
		base = ShopMenu(parentMenu);
	}
	
	override void Draw(double dT)
	{
		if(!objItem) return;
		if(!disabled && !dragging && checkDraggable() && CheckCollision(base.cursor, false))
		{
			// On hover
			MWDrawer.SetClipRect(parentElement.pos.x, parentElement.pos.y, parentElement.size.x, parentElement.size.y);
			MWDrawer.Fill(0x184073, parentElement.pos.x, pos.y - 7, parentElement.size.x - 40, size.y + 15, 0.33);
			MWDrawer.ClearClipRect();
		}
		
		DrawAt(pos, parentElement);
	}
	
	virtual void DrawAt(vector2 drawPos, MenuElement inContainer)
	{
		if(objItem)
		{	
			if(inContainer) MWDrawer.SetClipRect(inContainer.pos.x, inContainer.pos.y, inContainer.size.x, inContainer.size.y);
			if(!dragging)
			{
				MechItemSlot.DrawMechItem(objItem, drawPos, dragging ? 0.65 : 1.0, 0.5, size, 34, disabled);  
				DrawCount(drawPos);
				MWDrawer.ClearClipRect();
			}
			else
			{
				MechItemSlot.DrawMechItem(objItem, initPos + posOffs, 1.0, 0.5, size, 34, disabled);
				DrawCount(initPos + posOffs);
				MWDrawer.ClearClipRect();
				
				MechItemSlot.DrawMechItem(objItem, drawPos, dragging ? 0.65 : 1.0, 0.5, size, 34, disabled);  
			}
		}
	}
	
	virtual void DrawCount(vector2 drawPos)
	{
		bool isPlayerItem = base.PlayerItems.items.Find(objItem) != base.PlayerItems.items.Size();
	
		// Draw Price
		Color priceTagColor = 0xFF127012;
		vector2 priceStringPos = (drawPos.x + size.x + 12, drawPos.y + size.y - 8);
		string value = MWDrawer.FormatNumber(isPlayerItem ? objItem.value * 0.5 : objItem.value);
		double valLength = MWDrawer.GetTextWidth("SmallFont", value, (0.8,0.8));
		vector2 cbillIconPos = priceStringPos + (7 + valLength, 5);
		
		MWDrawer.Fill(priceTagColor, priceStringPos.x - 5, priceStringPos.y - 5, valLength + 20, 20);
		
		MWDrawer.DrawString("SmallFont", "\c[White]"..value, priceStringPos, scale:(0.8,0.8));
		MWDrawer.DrawImage("Graphics/Shop/CBill_Icon.png", cbillIconPos, scale:(0.5,0.5));
		
		MWDrawer.DrawImage("Graphics/Shop/priceTag.png", priceStringPos + (-14,5), scale:(0.3,0.3), tint:priceTagColor);
	
		if(infinite) return; // Do not draw quantity for infinite items.
		vector2 countStringPos = (parentElement.pos.x + (parentElement.size.x - 60), drawPos.y);
		MWDrawer.DrawString("SmallFont", String.Format("\c[Gray] %d", count), countStringPos, flags:MWDrawer.SS_TEXT_RIGHT);
	}
	
	override bool CheckDraggable()
	{
		// Items not visible on the list shouldn't be able to be dragged.
		return !disabled && (dragging || CheckCollision(parentElement, false));
	}
	
	override void UpdateDragPos(MenuCursor cursor)
	{
		vector2 centerPos = (
			( (size.x * 0.5) - (cursor.size.x * 0.5) ),
			( (size.y * 0.5) + (cursor.size.y * 0.5) )
		);
	
		pos = cursor.pos - centerPos;
	}
	
	override void OnDrag(MenuCursor cursor)
	{
		dragging = true;
	}
	
	override void OnDrop(MenuCursor cursor)
	{		
		// Finish dragging 
		dragging = false;
	
		if(inCart && !CheckCollision(base.shoppingCartContainer, true))
		{
			base.shoppingCartContainer.RemoveFromCart(self);
			return;
		}
	
		if(CheckCollision(base.shoppingCartContainer, true))
		{
			base.shoppingCartContainer.AddToCart(self);
		}
	}
	
	override void Update(double dT)
	{
		// Update size to item slot size.
		if(objItem) size.y = 34 * max(1,objItem.size) * 0.5;

		if(!dragging) pos = initPos + posOffs;
		disabled = parentElement.disabled || (!infinite && count <= 0);
		if(infinite) count = 1;
	}
}

class ShopScrollBar : MenuElement
{
	double curScroll;
	double itemListHeight;
	double scrollPerc;
	double scrollTo;
	
	override void Init()
	{
		size.y = parentElement.size.y;
	}

	override void Draw(double dT)
	{
		double scrollBarHeight = clamp( (size.y / max(1,itemListHeight + size.y)) * size.y, 16, size.y - 8);
		double scrollContainerHeight = size.y - scrollBarHeight - 8;
		vector2 scrollBarPos = (pos.x + 4, pos.y + (scrollContainerHeight * scrollPerc) + 4);
		vector2 scrollBarSize = (size.x * 0.8, scrollBarHeight);
		vector2 shadowPos = (2,2);
	
		// Background
		MWDrawer.Fill(0x7F7F7F, pos.x - shadowPos.x, pos.y - shadowPos.y, size.x + (shadowPos.x*2), size.y + (shadowPos.y*2));	
		MWDrawer.Fill(0x0F0F0F, pos.x, pos.y, size.x, size.y);	
		
		// Foreground
		MWDrawer.Fill(0xAFAFAF, scrollBarPos.x, scrollBarPos.y, scrollBarSize.x, scrollBarSize.y); 
		MWDrawer.Fill(0xFFFFFF, scrollBarPos.x + shadowPos.x, scrollBarPos.y + shadowPos.y, scrollBarSize.x - (shadowPos.x*2), scrollBarSize.y - (shadowPos.y*2)); 
	}
	
	override bool CheckDraggable()
	{
		return itemListHeight > 0;
	}
	
	override void UpdateDragPos(MenuCursor cursor)
	{
		if( cursor.pos.y < pos.y || cursor.pos.y > (pos.y + size.y) )
			return;
	
		double deltaY = cursor.pos.y - pos.y;
		double perc = clamp(deltaY / size.y, 0, 1.);
		
		scrollTo = perc * itemListHeight;
	}
	
	override void Update(double dT)
	{
		curScroll = clamp(curScroll, 0, itemListHeight);		
		scrollTo = clamp(scrollTo, 0, itemListHeight);		
		scrollPerc = curScroll / max(1,itemListHeight);
		
		if(abs(curScroll - scrollTo) > 1)
			curScroll = DrivablesMath.lerp(curScroll, scrollTo, 0.5 * dT);
	}
}

class ShopBackground : MenuElement
{
	override void Draw(double dT)
	{
		MWDrawer.Fill(0x3F3F3F, pos.x, pos.y, size.x, size.y, 1.0);
		
		// Background
		//MWDrawer.Fill(0x3F3F3F, pos.x, 230, size.x, size.y - 115);
	}
}


// Shop Menu
class ShopMenu : MechMenu 
{
	enum ShoppingMode
	{
		SHOP_NEUTRAL = 0,
		SHOP_BUYING = 1,
		SHOP_SELLING = 2
	};

	PlayerPawn shopPlayer;
	int shopMode; // enum field for ShoppingMode.
	Array<ShopItem> shopCart;
	
	I_MechItemStorage playerItems;
	
	ShopItemsContainer playerItemContainer;
	ShopItemsContainer shopItemContainer;
	CartContainer shoppingCartContainer;

	MenuCursor cursor;
	
	override void InitElements() 
	{
		elements.Clear(); // Repopulate elements
		shopMode = SHOP_NEUTRAL;
		
		shopPlayer = players[consoleplayer].mo;
		// Get pointer to player items.
		playerItems = I_MechItemStorage(shopPlayer.FindInventory("I_MechItemStorage"));
		
		AddElement("ShopBackground", "ShopField", (150,20), (1620,900));
		
		playerItemContainer = ShopItemsContainer(AddElement("ShopItemsContainer", "Current Inventory", (160,250), (520,650)));
		playerItemContainer.Setup(playerItems.items, NULL, SHOP_SELLING);
		
		shopItemContainer = ShopItemsContainer(AddElement("ShopItemsContainer", "Market Items", (1240,250), (520,650)));
		shopItemContainer.Setup(playerItems.shopItems, NULL, SHOP_BUYING);
		shopItemContainer.ChangeListing(ShopItemsContainer.LIST_ENGINES); 
		
		shoppingCartContainer = CartContainer(AddElement("CartContainer", "ShoppingCart", (770,250), (430,500)));
		
		// Cursor is added last, to keep always on-top.
		cursor = MenuCursor(AddElement("MenuCursor", "Cursor", (0,0), (10,10))); 
	}
		
	play static void processShopMenuEvents(ConsoleEvent e)
	{
		// Menu events
		let plr = players[e.Player].mo;
		
		string menuCmd = e.Name;
		Array<String> menuArgs;
		menuCmd.Split(menuArgs, ".");
	}
	
	override void processPlayEvent(int playerNumber, string event) 
	{
		Array<String> cmds;
		event.Split(cmds, ".");
	}
	
	override void OnElementEvent(MenuElement source, string eventType, int intArg, double doubleArg, Object objArg)
	{
		// MenuElements can call this function if they wish to relay behavior to their parent menu.
	}
}
