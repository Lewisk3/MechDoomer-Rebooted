class MechProjectile : FastProjectile
{
	vector3 spawnPos;
	double speedKPH;
	double curDist, minRange, maxRange;
	double firePitch; // Initial pitch offset when fired.
	double trueDamage;
	double homingTics; // Time spent actively homing.
	bool hasHoming;
	Actor homingTarget;
	Sound impactSnd;
	bool stopHoming;
	bool fullVolumeImpact;
	
	Property Ranges : minRange, maxRange;
	Property FirePitch : firePitch;
	Property Dmg : trueDamage;
	Property Homing : hasHoming;
	Property ImpactSound : impactSnd;
	Property GlobalImpactSound : fullVolumeImpact;
	Property SpeedKPH : speedKPH;
	
	Default
	{
		Scale 3.0;
		Speed 10;
		Projectile;
	}
	
	override void Tick()
	{
		super.Tick();
		
		// Determine geometric collision.
		if( !bMISSILE || vel ~== (0,0,0) ) return;
		
		FLineTraceData lt;
		LineTrace(angle, radius + vel.Length(), pitch, data:lt);
		
		let hitType = lt.HitType;
		if(hitType == TRACE_HitWall || hitType == TRACE_HitFloor || hitType == TRACE_HitCeiling) 
			PreGeometryHit(lt.HitLine, lt.HitSector); 
	}
	
	virtual void PreGeometryHit(Line ln, Sector sec)
	{
		if(impactSnd) // Play Impact sound effect.
			playImpactSound();
	}
	
	static double GetSpeedFromKPH(double KPH)
	{
		double kmPerSecond = KPH / 3600.0;
		double cmPerTick = (kmPerSecond / TICRATE) * 100000.0;
		
		return cmPerTick / UTOCM;
	}
	
	virtual void playImpactSound()
	{
		if(fullVolumeImpact)
			S_StartSound(impactSnd, CHAN_AUTO, CHANF_OVERLAP, attenuation:ATTN_NONE);
		else
			A_StartSound(impactSnd, CHAN_AUTO, CHANF_OVERLAP);
	}
	
	override void PostBeginPlay()
	{	
		super.postBeginPlay();
		spawnPos = pos;
		pitch -= firePitch;
		if(speedKPH > 0) A_SetSpeed(GetSpeedFromKPH(speedKPH)); 
		UpdateVelocity();
	}
	
	virtual void UpdateVelocity()
	{
		vel = DrivablesMath.VecFromAngles(angle, pitch, Speed);
	}
	
	override int SpecialMissileHit(Actor victim)
	{	
		let hardpoint = MechHardpoint(target);
		let hitHardpoint = MechHardpoint(victim);
		let hitMechBox = MechHitbox(victim);

		bool hitMechPart = hitHardpoint && hardpoint && hitHardpoint.mech == hardpoint.mech;
		hitMechPart |= hitMechBox && hardpoint && MechHardpoint(hitMechBox.parent).mech == hardpoint.mech;
		
		if( victim == target || victim == master || hitMechPart )
			return 1; // Ignore actor.
		
		if(impactSnd) // Play Impact sound effect.
			playImpactSound();

		// Hit a non-vehicle
		double damageMod = 1.0;
		if( !(victim is "DrivableObjectPart") ) damageMod = 2.7; 
		
		victim.DamageMobJ(self, master ? master : target, ceil(trueDamage * damageMod), DamageType, DMG_THRUSTLESS, angle);
		return super.SpecialMissileHit(victim);
	}
	
	virtual Actor SpawnEffect(class<Actor> trail, vector3 spawnPos)
	{
		let trail = Spawn(trail, spawnPos);
		if(trail) trail.A_SetScale(trail.default.Scale.X * scale.X);
		
		return trail;
	}
	
	virtual void HandleRanges()
	{
		curDist = (pos - spawnPos).Length();
		curDist = DrivableMech.unitsToKM(curDist) * 1000.0;
		
		if( firePitch && curDist < minRange )
		{
			pitch = -firePitch * (1.0 - (curDist/minRange));
			UpdateVelocity();
		}
	}
	
	virtual void HandleHoming(vector2 spread = (0,0), double strength = 0.6)
	{
		if(!homingTarget || homingTics > TICRATE || stopHoming) return;
		
		// Target is too close.
		vector3 spreadPos = Quat.FromAngles(angle, pitch, roll) * (0, spread.x, (homingTarget.height * 0.5) + spread.y);
		vector3 targetPos = level.vec3offset(homingTarget.pos, spreadPos);
		double targetDist = DrivablesMath.Distance3D(pos, targetPos);
		
		// If our target is really close, we shouldn't need to home anymore.
		if(targetDist <= 192) 
		{
			stopHoming = true;
			// strength = 1.0;
			return; 
		}
		if(curDist < minRange) return; // No homing if too close.
		
		
		vector3 homAngles = level.SphericalCoords(
			pos, targetPos, (angle, pitch)
		);
		
		// if(abs(homAngles.x) <= 20) strength = 1.0;
		vector3 toAngles = homAngles * strength;	
		
		angle -= toAngles.x;
		pitch -= toAngles.y;
		if(targetDist <= 512) homingTics++;
		
		UpdateVelocity();
	}
}