class MechFieldDrone : Actor
{
	Actor source; // Actor who deployed this drone.
	Actor engagingTarget;
	DrivableMech targetMech; // The mech to target.
	I_SaveMechData mechData;
	double power, maxPower; // Depletes over flight and repair time.
	double powerUse; // Power used on flight.
	vector3 animAngles; // Animated angles for inertial flight
	Quat rotation;
	
	vector3 cacheAngles; // Used to cache whatever angles needed. Used mostly for DRM_MANUAL.
	bool flyingManual;
	
	int mode;
		
	enum DroneModes 
	{
		DRM_FOLLOW_PASSIVE = 0,
		DRM_FOLLOW_ACTIVE = 1,
		DRM_IDLE = 2,
		DRM_MANUAL = 3,
		DRM_MECHUTILITY = 4,
		DRM_TURRET = 5
	};
		
	DroneLaserMount droneLaser;

	Default
	{
		Health 1000;
		Radius 5;
		Height 5;
		Scale 0.4;
		+SOLID;
		+INTERPOLATEANGLES;
		+NOGRAVITY;
		+CANPASS;
		+DROPOFF;
		+SLIDESONWALLS;
		+NOBLOCKMONST;
	}
	
	virtual void SetMode(int mode)
	{
		self.mode = mode;
	}
	
	virtual bool CheckCombatMode()
	{
		return mode == DRM_FOLLOW_ACTIVE || mode == DRM_TURRET;
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if(other == source) return false;
		return super.CanCollideWith(other, passive);
	}
	
	static MechFieldDrone DeployDrone(class<MechFieldDrone> drone, Actor source)
	{
		let fieldDrone = MechFieldDrone(Actor.Spawn(drone));
		if(fieldDrone)
		{
			fieldDrone.source = source;
			
			// Get target mech from source.
			let mechData = I_SaveMechData(source.FindInventory("I_SaveMechData"));
			if(!mechData || !mechData.lastPilotedMech) 
				console.printf("Drone AI [WARNING]: No active mech found.");
			else
				fieldDrone.targetMech = mechData.lastPilotedMech;
				
			fieldDrone.mechData = mechData;
			
			fieldDrone.OnDeploy();
		}
		return fieldDrone;
	}
	
	virtual void UpdateTargetMech()
	{
		if(!mechData) return;
		targetMech = mechData.lastPilotedMech;
	}
	
	virtual void OnDeploy()
	{
		rotation = Quat.FromAngles(angle, pitch, roll);
		A_FollowSource((0,0,0), -1);
		
		droneLaser = DroneLaserMount.Setup(self, (3.25,0,-11));
	}
	
	virtual void A_LookSourceDirection(double interp = 0.3)
	{
		if(!source) return;
		Quat toRotation = Quat.FromAngles(source.angle, source.pitch, source.roll);
		
		rotation = Quat.SLerp(rotation, toRotation, interp);
	}
	
	virtual void A_FollowSource(vector3 offs, double moveSpeed = 8, double lookSpeed = 0.1)
	{
		if(!source) return;
		
		offs *= Scale.X;
		
		Quat sourceDir = Quat.FromAngles(angle, pitch, roll);
		
		double bobz = 0;
		if(source.player)
		{
			double viewz = source.player.viewz;
			bobz = source.pos.z - (viewz - source.player.viewheight);
		}
		
		vector3 sourcePos = (source.pos.xy, (source.pos.z + source.height) - bobz);
		vector3 targetPos = level.vec3offset(sourcePos, sourceDir * offs);
		double dist = DrivablesMath.Distance3D(pos, targetPos);
		
		if( moveSpeed < 0 || dist >= 512) 
		{
			SetOrigin(targetPos, true);
			return;
		}
		
		if(dist <= 128)
			A_LookSourceDirection(lookSpeed);
		
		let diff = level.vec3diff(pos, targetPos).Unit();
		vel += diff * (min(1.0, DrivablesMath.fmap(dist, 0, 256, 0, 1.0)) * moveSpeed);
	}
	
	virtual void A_ProcessPilot()
	{
		// Source is the pilot of this drone.
		if(!source.player) return;
		
		UserCmd cmd = source.player.cmd;
		
		if(!flyingManual)
		{
			cacheAngles = (source.angle, source.pitch, source.roll);
			flyingManual = true;
		}
		
		// Keep pilot
		source.SetCamera(self);
		source.vel *= 0;
		source.player.vel = source.vel.xy;
		if(source.player.ReadyWeapon)
		{
			let psp = source.player.FindPSprite(PSP_WEAPON);
			if(psp) psp.tics = -1;
			source.player.weaponstate &= ~WF_WEAPONREADY;
		}
		
		// Movement
		double fw = cmd.forwardmove;
		double lr = cmd.sidemove;
		
		// Update view
		double scalar = (360 / 65536.0);

		double cmdYaw   =  cmd.yaw   * scalar;
		double cmdPitch = -cmd.pitch * scalar;
		double cmdRoll  =  cmd.roll  * scalar;
		
		// Create quaternion based on look delta
		Quat input = Quat.FromAngles(cmdYaw, cmdPitch, cmdRoll);
		
		// Offset our current rotation quaternion with look delta.
		rotation *= input;
		
		// Create quaternion based off our current facing direction
		// interpolate it to our new rotation based off our input delta.
		Quat r = Quat.FromAngles(angle, pitch, roll);
		r = Quat.SLerp(r, rotation, 0.4);
		
		// Movement
		vector3 dir;
		dir.z = (cmd.buttons & BT_JUMP) ? 1 : (cmd.buttons & BT_CROUCH) ? -1 : 0; 
		
		if(fw || lr) dir.xy = (fw, lr).Unit();
		
		vector3 wishDir = Quat.FromAngles(angle, pitch, roll) * (dir.x, -dir.y, dir.z);
		vel += wishDir * 1.8;
		
		if(cmd.buttons & BT_USE) 
			mode = DRM_FOLLOW_ACTIVE;
		
		// Reset source to cached angles.
		source.A_SetAngle(cacheAngles.z);
		source.A_SetPitch(cacheAngles.y);
		source.A_SetRoll(cacheAngles.z);
		source.player.cheats |= CF_INTERPVIEW;
		
		if(mode != DRM_MANUAL)
		{
			// Release pilot
			source.SetCamera(source);
			source.player.cheats &= ~CF_TOTALLYFROZEN;
			flyingManual = false;
			
			if(source.player.ReadyWeapon)
			{
				let psp = source.player.FindPSprite(PSP_WEAPON);
				if(psp) psp.tics = 1;
				source.player.weaponstate &= ~WF_WEAPONREADY;
			}
		}
	}
	
	override void Tick()
	{
		super.Tick();
		UpdateTargetMech(); 
		
		vel *= 0.8;
		animAngles *= 0.92;
		
		// Tilt in direction of movement
		double inertia = 0.75;
		
		double UD = vel dot (rotation * (0,0,1));
		double LR = vel dot (rotation * (0,1,0));
		double FB = vel dot (rotation * (1,0,0));
		
		animAngles.x += LR * inertia; // roll
		animAngles.y += FB * inertia; // pitch
		
		animAngles.x = clamp(animAngles.x, -70,70);
		animAngles.y = clamp(animAngles.y, -30,30);
		
		vector3 euler = DrivablesMath.getEuler(rotation);
		A_SetAngle(euler.x, SPF_INTERPOLATE);
		A_SetPitch(euler.y + animAngles.y, SPF_INTERPOLATE);
		A_SetRoll(euler.z - animAngles.x, SPF_INTERPOLATE);
		
		// Drone bob
		vel += (rotation * (0,0,1)) * (cos(level.maptime * 10) * 0.05); 
	}	
	
	// This enables state sequences to be overwritten in child classes.
	virtual state SetDroneState(bool condition, StateLabel stateName)
	{
		if(!condition) return ResolveState(null);
		return ResolveState(stateName);
	}
	
	States
	{
		Spawn:
			DRON A 1;
		goto Think;
		
		Think:
			TNT1 A 0 SetDroneState(mode == DRM_FOLLOW_PASSIVE || mode == DRM_FOLLOW_ACTIVE, "Follow");
			TNT1 A 0 SetDroneState(mode == DRM_IDLE, "Idle.Passive");
			TNT1 A 0 SetDroneState(mode == DRM_TURRET, "Idle.Active");
			TNT1 A 0 SetDroneState(mode == DRM_MECHUTILITY, "Mechutil");
			TNT1 A 0 SetDroneState(mode == DRM_MANUAL, "PilotMode");
		loop;
		
		Follow:
			DRON A 1 
			{
				A_FollowSource( (85, -50, -25), 8, 0.1);
			}
		goto Think;
		
		Idle.Passive:
			DRON A 1;
		goto Think;
		
		Idle.Active:
			DRON A 1
			{
				if(!engagingTarget)
					rotation *= Quat.FromAngles(-2,0,0);
			}
		goto Think;
		
		PilotMode:
			DRON A 1 A_ProcessPilot();
			DRON A 0 A_JumpIf(mode != DRM_MANUAL, "Think");
		loop;
		
		Mechutil:
			DRON A 1; // Do mech stuff here.
		goto Think;
	}
}

class DroneLaserMount : Actor
{
	MechFieldDrone parent;
	Actor laserTarget;
	vector3 targetOffs;
	vector3 laserOffs;
	vector3 parentOffs;
	DroneLaserBeam laser;
	Quat rotation;	
	Quat desiredRotation;

	Default
	{
		Height 0;
		Radius 0;
		+NOINTERACTION;
	}
	
	static DroneLaserMount Setup(MechFieldDrone parent, vector3 mountOffs, class<DroneLaserMount> mountType = "DroneLaserMount")
	{
		let lasermount = DroneLaserMount(Spawn(mountType));
		if(lasermount)
		{	
			lasermount.parent = parent;
			lasermount.parentOffs = mountOffs;
			lasermount.A_SetScale(parent.Scale.X);
			lasermount.rotation = Quat.FromAngles(parent.angle, parent.pitch, parent.roll);
			lasermount.desiredRotation = lasermount.rotation;
		}
		return lasermount;
	}
	
	void FindTarget()
	{			
		laserTarget = NULL;
		let it = ThinkerIterator.Create();
		Actor act;
		double closest = laserTarget ? Distance3D(laserTarget) : double.infinity;
		double sq_mindist = 64;
		double sq_maxdist = 2048;
		while (act = Actor(it.Next()))
		{
			double dist = Distance3D(act);
			if(dist > closest || dist < sq_mindist || dist > sq_maxdist) continue;
			if(act == parent || act == parent.source) continue;
			
			if(act == self || act == target) continue;
			if(!act.bSHOOTABLE || (target && target.player && !act.bISMONSTER) || act.bKILLED) continue;   
			if(!CheckTargetReachable(act)) continue;
			
			laserTarget = act;
			closest = dist;
		}
		
		if(parent) parent.engagingTarget = laserTarget;
	}
	
	virtual bool CheckTargetReachable(Actor act)
	{
		if(!act) return true;
		
		double dist = Distance3D(act);
		vector3 firePos = (act.pos.xy, act.pos.z + (act.height * 0.5));
		vector3 angles = level.sphericalCoords(pos, firePos, (0,0));
		
		LookExParams look;
		look.FOV = 360;
		if(!IsVisible(act, true, look)) return false; // Actor is behind wall.  
			
		FLineTraceData hitData;
		vector3 ltPos = level.vec3offset(pos, rotation * (30,0,0));
		LineTrace(-angles.x, dist, -angles.y, TRF_ABSPOSITION, ltPos.z, ltPos.x, ltPos.y, data:hitData);
		if(hitData.HitType == TRACE_HitActor && hitData.hitActor == act) return true;
		
		return false;
	}
	
	override void Tick()
	{
		super.Tick();
		
		if(!parent) return;
		bool inCombatMode = parent.CheckCombatMode();
		
		laserOffs = (10,0,0) * Scale.X;
		
		if(!laser) 
		{
			laser = DroneLaserBeam(DroneLaserBeam.Create(
				self, 
				laserOffs.x, laserOffs.y, laserOffs.z, 
				0,0, 
				type:"DroneLaserBeam"
			));
			laser.A_SetScale(laser.Scale.X * Scale.X);
		}
		
		Quat followDir = Quat.FromAngles(parent.angle, parent.pitch, parent.roll);
		vector3 desiredEuler = DrivablesMath.getEuler(desiredRotation);
		double rotDiff = abs(angle - desiredEuler.x) + abs(pitch - desiredEuler.y);
		
		if(parent.mode != MechFieldDrone.DRM_MANUAL)
		{
			laser.SetEnabled(!!laserTarget && rotDiff <= 10 && inCombatMode); 
		}
	
		vector3 followPos = level.vec3offset(parent.pos, followDir * (parentOffs * scale.X));
		SetOrigin(followPos, true);
		
		rotation = Quat.SLerp(rotation, desiredRotation, 0.2);
		vector3 euler = DrivablesMath.getEuler(rotation);
		A_SetAngle(euler.x, SPF_INTERPOLATE);
		A_SetPitch(euler.y, SPF_INTERPOLATE);
		A_SetRoll(euler.z, SPF_INTERPOLATE);
		
		if(!CheckTargetReachable(laserTarget)) laserTarget = NULL;
		
		if(!laserTarget) 
		{
			desiredRotation = followDir; 
			if(parent.mode != MechFieldDrone.DRM_MECHUTILITY) FindTarget();
		}
		else
		{	
			if(laserTarget.bCORPSE || laserTarget.health <= 0) 
			{
				laserTarget = NULL;
				return;
			}
			
			vector3 firePos = (laserTarget.pos.xy, laserTarget.pos.z + (laserTarget.height * 0.5));
			vector3 angles = level.sphericalCoords(pos, firePos, (0,0));
			
			desiredRotation = Quat.FromAngles(-angles.x, -angles.y, parent.roll);
		}	
		
		if(!inCombatMode)
			desiredRotation = Quat.FromAngles(parent.angle, parent.pitch - 20, parent.roll);
		
		if(parent.mode == MechFieldDrone.DRM_MANUAL && parent.source.player)
		{
			// Aim towards screen crosshair
			FLineTraceData hitData;
			vector3 ltPos = level.vec3offset(parent.pos, Quat.FromAngles(parent.angle, parent.pitch, parent.roll) * (30,0,0));
			parent.LineTrace(parent.angle, 1024, parent.pitch, TRF_ABSPOSITION, ltPos.z, ltPos.x, ltPos.y, data:hitData);
			
			vector3 angles = level.sphericalCoords(pos, hitData.hitLocation, (0,0));
			desiredRotation = Quat.FromAngles(-angles.x, -angles.y, parent.roll);
			
			laser.SetEnabled(parent.source.player.cmd.buttons & BT_ATTACK);
		}
	}
	
	States
	{	
		Spawn:
			LASR A -1;
		stop;
	}
}

class DroneLaserBeam : MechLaserBeam
{
	double trueDamage;
	Property LaserDamage : trueDamage;

	Default
	{
		Scale 1.0;
		RenderStyle "AddShaded";
		DroneLaserBeam.LaserDamage 1;
		
		MechLaserBeam.LaserColor "Red";
	}
	
	override void BeamTick()
	{
		if( hitData.hitType != TRACE_HitNone && trueDamage > 0 ) 
			OnImpact(hitData.HitLocation, hitData.hitActor);
	}
	
	override void OnImpact(vector3 hitPos, Actor hitActor)
	{
		let droneSource = DroneLaserMount(source);
		if(droneSource && hitActor == droneSource.parent.source) 
		{
			SetEnabled(false);
			return;
		}
	
		let lasdec = Spawn("MWLaserDecal", hitPos);
		lasdec.angle = angle;
		lasdec.pitch = pitch;
		lasdec.target = self;
	
		if(hitActor) 
		{
			if(hitActor is "MechHardpoint") return; // Skip
			
			hitActor.DamageMobJ(self, source, trueDamage, "Fire");
			if(alpha >= 0.7) A_StartSound("Laser/Impact", CHAN_WEAPON, flags:CHANF_NOSTOP);
		}
	}
	
	override void Tick()
	{
		super.Tick();
		alpha = cos(level.maptime * 20);
		
		if(enabled)
		{
			A_StartSound("Laser/Loop", flags:CHANF_LOOPING|CHANF_NOSTOP);
		}
		else
		{
			A_StopSound(CHAN_BODY);
		}	
	}
}

class FieldDroneItem : Inventory
{
	class<MechFieldDrone> droneCls;
	
	Property DroneClass : droneCls;

	Default
	{
		Inventory.MaxAmount 1;
		Inventory.Icon "CELLA0";
		FieldDroneItem.DroneClass "MechFieldDrone";
		
		+INVENTORY.AUTOACTIVATE;
	}
	
	override bool Use(bool pickup)
	{
		let drone = MechFieldDrone.DeployDrone(droneCls, Owner);
		drone.SetMode(MechFieldDrone.DRM_FOLLOW_ACTIVE);
		return true;
	}
	
	States
	{
		Spawn:
			PLSS A -1;
		loop;
	}
}

class MechRepairDrone : MechFieldDrone
{
}