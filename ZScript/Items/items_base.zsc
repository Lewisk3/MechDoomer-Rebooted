class MechItem : Object
{
	I_MechItemStorage inv; // Non-mech inventory
	MechHardpoint parent;
	DrivableMech mech;
	double hp;
	int size;
	bool movable, damagable, disabled, nosave; // No Save means this item is not saved into mech data.
	string displayName;
	int amount;
	double weight;
	double value; // CBill value
	Sound sndItemName;
	bool template; // If true, this item is not returned on Init. 
	bool essential; // If true, item is added to the inventory by default.
	bool hidden; // If true, item is hidden from inventory screen.
	bool infinite; // Item cannot be depleted.
	string itemDescription;
	bool addonCapable; // If false, addon logic will be skipped for this item.
	
	enum ItemActionError 
	{
		IAE_FAIL 		= 0,
		IAE_NOSLOTS 	= 1,
		IAE_OVERWEIGHT  = 2,
		IAE_INVALID 	= 3,
		IAE_EXCLUSIVE	= 4,
		IAE_NOTFOUND	= 5,
		IAE_TOOCOMPLEX  = 6,
		IAE_NOMONEY		= 7,
		IAE_SUCCESS 	= 0xFF
	};
	
	clearscope virtual bool isTypeOf(class<MechItem> item, bool subclass = false)
	{	
		return ((self is item) && subclass) || getClass() == item;
	}
	
	clearscope static MechItem Init(class<MechItem> type)
	{
		let item = MechItem(new(type));
		if(item) 
		{
			item.Movable = true;
			item.hp = 10;
			item.size = 1; 
			item.amount = 1;
			item.damagable = false;
			item.Defaults();
		}
	
		return (item && item.template) ? NULL : item;
	}
	
	// Returns cbill value of item
	clearscope virtual double GetValue()
	{
		return value;
	}
	
	play virtual void ToggleState()
	{
		// Called with toggle weapon state button is pressed.
	}
	
	clearscope virtual void GetUIColors(out int fontColor, out int bgColor)
	{		
		if(!movable)
		{
			fontColor = Font.CR_BLACK;
			bgColor = 0;
		}
	}
	
	virtual string GetItemErrorMessage(int ERR_TYPE)	
	{
		switch(ERR_TYPE)
		{
			case IAE_FAIL	   : return ("Failed to equip item.");
			case IAE_NOSLOTS   : return ("Not enough slots!");
			case IAE_OVERWEIGHT: return ("Overtonnage!");
			case IAE_INVALID   : return ("This item cannot be equipped here.");
			case IAE_EXCLUSIVE : return ("Only one of these items may be equipped.");
			case IAE_NOTFOUND  : return ("Missing component.");
			case IAE_TOOCOMPLEX: return ("Mech' structure is too complex to be modified.");
			case IAE_NOMONEY   : return ("Insufficient funds.");
			
			// No Error message.
			case IAE_SUCCESS:
			default: return "";
		}
	}
	
	// Called to check if new item should be added to `amount` or physically differentiated.
	virtual bool CanStack(MechItem other)
	{
		return (other.getClass() == getClass()) && (other.hp == hp && movable);
	}
	
	// Called when item is added to inventory (Not attached to a mech)
	virtual void OnInventoryAdd(I_MechItemStorage destInv) 
	{
		inv = destInv;
	}
	
	// Addon control, called when an item is dropped onto another.
	play virtual void ApplyAddon(MechItem addon) {}
	play virtual void OnAddon(MechItem destItem) {}
	
	clearscope virtual bool isEquipped(DrivableMech mech = NULL)
	{
		return !!parent;
	}
	
	clearscope void appendItemDescription(out string flavorText)
	{
		flavorText = itemDescription == "" ? flavorText : String.Format("%s\n%s", flavorText, itemDescription);
	}
	
	clearscope virtual void getDescription(out string flavorText, out Array<String> statName, out Array<String> statValue, DrivableMech mechInfo = NULL)
	{
		if(checkDestroyed())
		{
			flavorText = "\c[Red]DESTROYED\c[White]";
			//return;
		}
		else if(hp < 10)
		{
			flavorText = "\c[Orange]DAMAGED\c[White]";
		}
		else
		{
			flavorText = "";
		}
		appendItemDescription(flavorText);
		
		statName.Push("SLOTS");
		statName.Push("TONS");
		statValue.Push(String.Format("%d", size));
		statValue.Push(String.Format("%.2f", weight));
		
		if(damagable)
		{
			statName.Push("HEALTH");
			statValue.Push(String.Format("%d / %d", hp, 10));
		}
	}
	
	clearscope virtual string GetShopDescription()
	{
		return "Item has no description.";
	}
	
	clearscope virtual void GetShopProperties(out Array<String> stats, out Array<string> values)
	{
		// Properties added here
	}
	
	virtual MechItem MakeCopy()
	{
		let item = MechItem.Init(getClass());
		item.hp = hp;
		return item;
	}
	
	play virtual void Deplete(bool keepdepleted = false)
	{
		if(--amount <= 0 && !keepdepleted)  
		{
			if(parent)
			{
				TryDetach(forced:true);
				Destroy();
			}
			else if(inv)
			{
				inv.depleteItem(self);
			}
		}
	}
	
	play virtual int TryAttach(MechHardpoint part, bool forced = false)
	{
		if(part.mech.noItemSlots) return false;
		if(part.healthPoints <= 0 && !forced) return IAE_INVALID;
		
		if (size > 0 && !forced)
		{
			if( (part.slots + size) > part.maxslots ) return IAE_NOSLOTS;
			if( (part.mech.weight + weight) > part.mech.maxWeight ) 
				return IAE_OVERWEIGHT;	
				
			int freeSlots = MechDynamicStructure.getTotalFreeslots(part.mech);
			if( (freeSlots - size) < 0 ) return IAE_NOSLOTS;
		}
		
		parent = part;
		part.items.Push(self);
		OnAttach();
				
		part.slots += size;
		part.mech.weight += weight;
		return IAE_SUCCESS;
	}
	
	play virtual bool TryDetach(bool forced = false)
	{
		if(!movable && !forced || !parent) return false;
		uint id = parent.items.Find(self);
		
		parent.items.Delete(id);
		parent.slots -= size;
		parent.mech.weight -= weight;
		OnDetach();
		
		parent = NULL;
		return true;
	}
	
	clearscope virtual void Defaults()
	{
		// Used to set defaults as we cannot otherwise.
	}
	
	play virtual void OnAttach()
	{	
		mech = parent.GetMech();
		inv = NULL; // We're no longer located in non-mech inventory.
	}
	
	play virtual void OnDetach()
	{
		// Reattach dynamic structures
		MechDynamicStructure.ReattachAll(mech);
	}
	
	play virtual void OnDamaged(double dmg)
	{
		if(!damagable || hp <= 0) return;
	
		if( sndItemName && hp >= 10 && int(hp-dmg) < 10 )
		{
			mech.betty.Push(sndItemName);
			mech.betty.Push("Betty/Item/Damaged");
		}
	
		// Do stuff when damaged.
		hp -= dmg;
		if(hp <= 0) OnDestroyed();
	}
	
	play virtual void OnDestroyed()
	{
		// Do stuff when destroyed.
		if(sndItemName)
		{
			mech.betty.Push(sndItemName);
			mech.betty.Push("Betty/Item/Destroyed");
		}
	}
	
	virtual bool checkDestroyed()
	{
		if(!parent) return hp <= 0;
		return hp <= 0 || parent.healthPoints <= 0;
	}
	
	play virtual void modifyHeat(double amt)
	{
		mech.modifyHeat(amt);
		parent.adjustLocalHeat(amt);
	}
	
	play virtual void modifyEnergy(double amt)
	{
		let engine = mech.engine;
		if(!engine) return;
		engine.energy -= amt;
	}
	
	play virtual void Repair(int amt)
	{
		hp = min(10, hp+amt);
	}
	
	play virtual void DoEffect()
	{
		// Process destruction.
		if(!parent) return;
	
		// Under normal circumstances, if our hardpoint was destroyed, we took a lot of damage too.
		if(parent.healthPoints <= 0) hp = 0;
	
		if(!mech) mech = parent.getMech();
	}
}

class MechAmmo : MechItem
{
	int curAmmo;
	int maxAmmo;
	double explosionDamage;
	class<MechAmmo> baseAmmoClass;
	
	override void Defaults()
	{
		damagable = true;
		explosionDamage = 1;
		baseAmmoClass = "";
	}
	
	override double getValue()
	{
		return max(value * 0.1, value * (curAmmo/double(maxAmmo)));
	}
	
	override bool isTypeOf(class<MechItem> item, bool subclass)
	{
		if(subclass) return super.isTypeOf(item, subclass);
	
		if(curAmmo <= 0) return false;
		
		return getClass() == item || baseAmmoClass == item;
	}
	
	override void GetUIColors(out int fontColor, out int bgColor)
	{
		bgColor = curAmmo <= 0 ? 0xA0000000 : 0xA0C700C7;
	}
	
	virtual void SetupAmmo()
	{
		curAmmo = maxAmmo;
	}
	
	override void OnDestroyed()
	{
		if(curAmmo <= 0 || !explosionDamage) return;
		mech.betty.Push("Betty/AmmoExplosion");
		parent.DoExplosionDamage(curAmmo * explosionDamage);
		curAmmo = 0;
		
		// Discard item
		TryDetach(forced:true);
	}
	
	override bool CanStack(MechItem other)
	{
		bool res = super.CanStack(other);
		return res && MechAmmo(other).curAmmo == curAmmo;
	}
	
	override void getDescription(out string flavorText, out Array<String> statName, out Array<String> statValue, DrivableMech mechInfo)
	{
		super.getDescription(flavorText, statName, statValue);
		if(curAmmo <= 0) flavorText = "\c[Yellow]DEPLETED";
		appendItemDescription(flavorText);
		
		statName.Push(" ");
		statValue.Push(" ");
		
		statName.Push("AMMO");
		statValue.Push(String.Format("%d / %d", curAmmo, maxAmmo));
	}
	
	override string getShopDescription()
	{
		int typeIndex = displayName.IndexOf("Ammo");
		if(typeIndex == -1) return "Ammunition";
		
		return String.Format("Ammo for %s'", displayName.Mid(0, typeIndex-1));
	}
	
	
	override void GetShopProperties(out Array<String> stats, out Array<string> values)
	{
		stats.Push("Capacity");
		values.Push(String.Format("%d", maxAmmo));
		
		if(curAmmo < maxAmmo)
		{
			stats.Push("Available Ammunition");
			values.Push(String.Format("%d", curAmmo));
		}
		
		stats.Push("Price-Per-Round");
		values.Push(String.Format("%d", (value * 0.9) / maxAmmo));
	}	
	
	override MechItem MakeCopy()
	{
		let item = MechAmmo(super.MakeCopy());
		item.curAmmo = curAmmo;
		item.maxAmmo = maxAmmo;
		return item;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		
		// Discard when depleted.
		
		/*
		if(curAmmo <= 0) 
			TryDetach(forced:true);
		*/
	}
}

class MechDynamicStructure : MechItem
{
	int prevFreeslots;

	override void Defaults()
	{
		movable = false;
		weight = 0;
		size = 0;
		nosave = true;
		displayName = "Structure";
	}
	
	play static void ReattachAll(DrivableMech mech)
	{	
		Array<MechHardpoint> hardpoints;
		mech.getHardPoints(hardpoints);
		
		Array<MechDynamicStructure> dynStructs;
		foreach(hardpoint : hardpoints) foreach(item : hardpoint.items)
		{
			let dynItem = MechDynamicStructure(item);
			if(dynItem) dynStructs.Push(dynItem);
		}
		
		foreach(dynItem : dynStructs) dynItem.TryDetach(true);
		foreach(dynItem : dynStructs) 
		{
			dynItem.size = 0; // Item will fail to reattach unless this is set first.
			dynItem.TryAttach(mech.torso);
		}
	}

	override void GetUIColors(out int fontColor, out int bgColor)
	{
		fontColor = Font.CR_BLACK;
		bgColor = 0xB2000000;
	}	
	
	clearscope virtual int getFreeslots()
	{
		int curSlots = parent.slots;
		int maxSlots = parent.maxSlots;
		curSlots += parent.countItems("MechDynamicStructure", true);
		
		return (maxSlots-curSlots);
	}
	
	clearscope static int getTotalFreeslots(DrivableMech mech)
	{
		int maxSlots;
		int curSlots;
		Array<MechHardpoint> hardpoints;
		mech.getHardPoints(hardpoints);
		
		for(int i = 0; i < hardpoints.Size(); i++)
		{
			let hardpoint = hardpoints[i];
					
			for(int x = 0; x < hardpoint.items.Size(); x++)
			{
				let item = hardpoint.items[x];
				if(item is "MechDynamicStructure") continue;
				curSlots += item.size;
			}
			
			curSlots += hardpoint.countItems("MechDynamicStructure", true);
			maxSlots += hardpoint.maxSlots;
		}
		
		return (maxSlots-curSlots);
	}
	
	clearscope static MechHardpoint findFreeslots(DrivableMech mech)
	{
		Array<MechHardpoint> hardpoints;
		mech.getHardPoints(hardpoints);
		
		// Sort hardpoint priorities
		foreach(hardpoint : hardpoints)
		{
			int curSlots = 0;
			foreach(item : hardpoint.items)
			{
				if(item is "MechDynamicStructure") continue;
				curSlots += item.size;
			}
			curSlots += hardpoint.countItems("MechDynamicStructure", true);
			
			int freeSlots = hardpoint.maxSlots - curSlots;
			if(freeSlots > 0) return hardpoint;
		}
		
		return NULL;
	}
	
	play virtual void ReAttach()
	{
		let freeHardpoint = findFreeslots(mech);
		if(freeHardpoint)
		{
			TryDetach(true);
			TryAttach(freeHardpoint);
		}
	}
	
	override void OnDetach()
	{
		// Don't do anything special
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		int curFreeslots = getFreeslots();
		MechHardpoint freeHardpoint = findFreeslots(mech);
		
		// Scale HP to internals health.
		hp = floor((parent.healthPoints / parent.maxHP) * 10);
		
		if(parent.healthPoints <= 0) return; // Do not move if we're in a dead hardpoint.
		if( (curFreeslots <= 1 && !freeHardpoint) && size < 1 )
		{
			size = 1;
			parent.slots++;
		} 
		
		if(freeHardpoint && size > 0)
		{
			size = 0;
			parent.slots--;
		}
		
		if( curFreeslots < 0 && freeHardpoint != parent )
		{
			ReAttach();
		}
	}
}

class MechUtility : MechItem 
{
	override void Defaults()
	{
		template = true;
	}
	
	// How many CBills this util costs to equip.
	// Managed differently by each item type.
	virtual double GetEquipmentCost(DrivableMech mech)
	{
		return 0;
	}
}
class MechArmor : MechUtility
{
	double armorWeight;
	double armorAmount;
	double damageMod;
	int armorTier; // 0 is repairable by any armor kit. 1 requires an advanced armor kit.
	class<MechDynamicStructure> structType;
	int structureSlots;
	double costPerTon; // CBill armor cost per-ton.

	override void Defaults()
	{
		// Setup default armor flags
		essential = infinite = hidden = true;
		damagable = false;
		
		size = 0; 
		structType = "MechDynamicStructure";
		structureSlots = 0;
		armorWeight = 0.05;
		armorTier = 0;
	}
		
	override void getDescription(out string flavorText, out Array<String> statName, out Array<String> statValue, DrivableMech mechInfo)
	{
		statName.Push("ARMOR WEIGHT");
		statValue.Push(String.Format("%.2f", armorWeight));
		
		statName.Push("CRITICALS");
		statValue.Push(String.Format("%d", structureSlots));
		
		if(damageMod < 1.0)
		{
			statName.Push("ABSORBTION");
			statValue.Push(String.Format("%d\%", 1.0-damageMod));
		}
	}
	
	play static bool addToMech(DrivableMech mech, class<MechArmor> type = "MechArmor")
	{
		let ar = MechItem.Init(type);
		if(ar) return ar.TryAttach(mech.torso, forced:true) == IAE_SUCCESS;
		return false;
	}
	
	virtual double ProcessDamage(double amt)
	{
		return amt * damageMod;
	}
	
	clearscope static double getMaxArmorPoints(DrivableMech mech)
	{
		double maxArmorPts = 0;
		Array<MechHardpoint> hardpoints;
		mech.getHardPoints(hardpoints);
		
		for(int i = 0; i < hardpoints.Size(); i++)
			maxArmorPts += hardpoints[i].maxArmor;
		
		return maxArmorPts;
	}
	
	clearscope static double getArmorPoints(DrivableMech mech)
	{
		double fullArmorPts = 0;
		Array<MechHardpoint> hardpoints;
		mech.getHardPoints(hardpoints);
		
		for(int i = 0; i < hardpoints.Size(); i++)
		{
			let hardpoint = hardpoints[i];
			fullArmorPts += (hardpoint.armorPoints + hardpoint.rearArmor);
		}
		return fullArmorPts;
	}
	
	override void DoEffect()
	{
		if(!mech) return;
		
		// Keep armor weight stable.
		double fullArmorPts = getArmorPoints(mech);
		if(armorAmount != fullArmorPts) 
		{
			mech.weight -= (armorAmount * armorWeight);
			armorAmount = fullArmorPts;	
			mech.weight += (armorAmount * armorWeight);
		}
	}
	
	override double getEquipmentCost(DrivableMech mech)
	{
		double tons = getMaxArmorPoints(mech) * armorWeight;
		return costPerTon * tons;
	}
	
	// Forced skips cbill transaction
	override int TryAttach(MechHardpoint part, bool forced)
	{
		let mech = part.mech;
		if( !mech || (mech.armorType && mech.armorType.getClass() == getClass()) ) return IAE_FAIL;
		if(mech.noItemSlots) return IAE_NOSLOTS;
		
		let prevArmor = mech.armorType;		
		
		if(prevArmor && (prevArmor.armorTier-1) > armorTier)
			return IAE_TOOCOMPLEX;
			
		double cbillChange = (prevArmor ? prevArmor.getEquipmentCost(mech) : 0) - getEquipmentCost(mech);
		if(forced) cbillChange = 0;
		
		if(inv && (inv.cbills + cbillChange) < 0)
			return IAE_NOMONEY;
		
		if(prevArmor) prevArmor.OnDetach();
		mech.armorType = NULL;
		
		int fail = IAE_SUCCESS;
		double weight = armorWeight*getArmorPoints(mech);
		
		if( (mech.weight + weight) > mech.maxWeight ) fail = IAE_OVERWEIGHT; 
		if(structureSlots > 0 && MechDynamicStructure.getTotalFreeslots(mech) < structureSlots)
			fail = IAE_NOSLOTS;
			
		if(fail != IAE_SUCCESS)
		{
			if(prevArmor) 
				prevArmor.TryAttach(part);
			else
				console.printf("Error: Failed to re-attach armor");
		}
		else
		{
			// Modify user cbills by equipmentCost
			if(inv) inv.cbills += cbillChange;
		
			self.mech = mech;
			self.armorAmount = 0;
			mech.armorType = self;
			OnAttach();
		}
		return fail;
	}
	
	override bool isEquipped(DrivableMech mech)
	{
		if(!mech.armorType) return false;
		return mech && mech.armorType.getClassName() == getClassName();
	}
	
	override bool TryDetach(bool forced)
	{
		OnDetach();
		return true;
	}
	
	override void OnAttach()
	{	
		DoEffect(); // Setup tonnage.
		for(int i = 0; i < structureSlots; i++)
			mech.torso.AddItem(structType);
	}
		
	override void OnDetach()
	{
		// Remove armor weight from mech.
		mech.weight -= (getArmorPoints(mech) * armorWeight);
		armorAmount = 0;
		
		if(structureSlots > 0)
		{
			MechItem structSlot;
			while(structSlot = mech.findItem(structType))
				structSlot.TryDetach(forced:true);
		}
		
		mech = NULL;
	}
}

class MechChassisStructure : MechUtility
{
	double chassisWeightPercent;
	class<MechDynamicStructure> structType;
	int structureSlots;
	int structureTier;
	double costPerTon; // Per-ton of structural materials.

	override void Defaults()
	{
		// Setup default armor flags
		essential = infinite = hidden = true;
		damagable = false;
		
		size = 0; 
		structType = "MechDynamicStructure";
		structureSlots = 0;
		chassisWeightPercent = 1.0;
		structureTier = 0;
	}
	
	override double getEquipmentCost(DrivableMech mech)
	{
		return costPerTon * (mech.maxWeight * 0.1 * chassisWeightPercent);
	}
		
	override void getDescription(out string flavorText, out Array<String> statName, out Array<String> statValue, DrivableMech mechInfo)
	{
		statName.Push("CHASSIS WEIGHT");
		statValue.Push(String.Format("%d%%", chassisWeightPercent*100.0));
		
		statName.Push("CRITICALS");
		statValue.Push(String.Format("%d", structureSlots));
	}
	
	play static bool addToMech(DrivableMech mech, class<MechChassisStructure> type = "MechChassisStructure")
	{
		let ar = MechItem.Init(type);
		if(ar) return ar.TryAttach(mech.torso, forced:true) == IAE_SUCCESS;
		return false;
	}
	
	// Forced bypasses cbill transaction.
	override int TryAttach(MechHardpoint part, bool forced)
	{
		let mech = part.mech;
		if(!mech) return IAE_FAIL;
		if(mech.noItemSlots) return IAE_NOSLOTS;
		self.mech = part.mech;
		
		let prevStructure = mech.chassisStructure;
		if(prevStructure && (prevStructure.structureTier-1) > structureTier)
			return IAE_TOOCOMPLEX;
		
		double cbillChange = (prevStructure ? prevStructure.getEquipmentCost(mech) : 0) - getEquipmentCost(mech);
		if(forced) cbillChange = 0;
		
		if(inv && (inv.cbills + cbillChange) < 0) 
			return IAE_NOMONEY;
		
		if(prevStructure) prevStructure.OnDetach();
		mech.chassisStructure = NULL;
		
		int fail = IAE_SUCCESS;
		double weight = getChassisWeight();
		if( (mech.weight + weight) > mech.maxWeight ) fail = IAE_OVERWEIGHT; 
		if(structureSlots > 0 && MechDynamicStructure.getTotalFreeslots(mech) < structureSlots)
			fail = IAE_NOSLOTS;
			
		if(fail != IAE_SUCCESS)
		{
			prevStructure.TryAttach(part);
		}
		else
		{
			if(inv) inv.cbills += cbillChange;
			mech.chassisStructure = self;
			OnAttach();
		}
		return fail;
	}
	
	virtual double GetChassisWeight()
	{
		if(!mech) return 0;
		return (mech.maxWeight / 10.0) * chassisWeightPercent;
	}
	
	override bool isEquipped(DrivableMech mech)
	{
		if(!mech.chassisStructure) return false;
		return mech && mech.chassisStructure.getClassName() == getClassName();
	}
	
	override bool TryDetach(bool forced)
	{
		OnDetach();
		return true;
	}
	
	override void OnAttach()
	{
		mech.weight += getChassisWeight();
		for(int i = 0; i < structureSlots; i++)
			mech.torso.AddItem(structType);
	}
		
	override void OnDetach()
	{
		// Remove structural weight from mech.
		mech.weight -= getChassisWeight();
		
		MechItem structSlot;
		while(structSlot = mech.findItem(structType))
			structSlot.TryDetach(forced:true);
	}
}

class MechEngineBlock : MechItem
{
	override void Defaults()
	{
		movable = false;
		weight = 0;
		size = 2;
		nosave = true; 
		displayName = "??? ENGINE";
	}
	
	override void GetUIColors(out int fontColor, out int bgColor)
	{
		fontColor = Font.CR_WHITE;
		bgColor = 0xFF670000;
	}
	
	override void getDescription(out string flavorText, out Array<String> statName, out Array<String> statValue, DrivableMech mechInfo)
	{
		// Report back engine description
		mech.engine.GetDescription(flavorText, statName, statValue, mechInfo);
	}
}

class MechEngine : MechItem
{
	double baseHeatEff;
	double baseValue;
	int rating, type;
	uint blocks, blockSize; // How many engine blocks to add to both side torsos.
	Array<MechItem> engineBlocks;
	Array<MechHeatsink> heatSinks;
	double energy; // Reactor available energy
	
	enum EngineType 
	{
		Type_STD,
		Type_Light,
		Type_XL,
		Type_XXL
	}
	
	virtual double GetPrice()
	{
		double typeMod[] = {
			1.0,
			1.5,
			2.7,
			8.0
		};
	
		return baseValue * rating * typeMod[type];
	}
	
	override void GetUIColors(out int fontColor, out int bgColor)
	{
		bgColor = 0xFF870202;
	}
	
	double roundTons(double value)
	{	
		return ceil(value*2.0)/2.0;
	}
	
	override void getDescription(out string flavorText, out Array<String> statName, out Array<String> statValue, DrivableMech mechInfo)
	{
		super.getDescription(flavorText, statName, statValue);
		statName.Push(" ");
		statValue.Push(" ");
		
		// Modify slots to reflect side slots
		int slotsIndex = statName.Find("SLOTS");
		statValue[slotsIndex] = String.Format("%d", size + (blocks*2) * blockSize);
		
		statName.Push("SIDE SLOTS");
		statValue.Push(String.Format("%d",blocks*blockSize));
		
		statName.Push("HEATSINKS");
		statValue.Push(String.Format("%d",floor(rating*0.04)));
		
		if(mechInfo)
		{
			statName.Push("TOP SPEED");
			statValue.Push(String.Format("%.2f KPH", getKPH(mechInfo)));
			
			let [runMP, walkMP] = getRunWalkMP(mechInfo);
			statName.Push("JUMP RANGE");
			statValue.Push(String.Format("%d m", walkMP));
		}
	}
	
	override string GetShopDescription()
	{
		switch(type)
		{
			case Type_STD: return (
				"\c[White] The fusion engine is capable of powering 'Mechs, Aerospace Fighters, "
				"and other vehicles. Fusion engines function by harnessing the power of a fusion "
				"reaction, as occurs in the core of the Sun. A BattleMech's fusion engine can usually "
				"last for decades on a few kilograms of hydrogen. "
				"\n(Source: https://www.sarna.net/wiki/Fusion_engine)"
			);
			case Type_Light: return (
				"\c[White]The light fusion engine weighs only 75% of a standard "
				"fusion engine. While not as dramatic as the 50% weight saving "
				"of an XL Engine, the real benefit of the light fusion engine is that "
				"while it intrudes into the side torsos of a BattleMech, it takes up the "
				"same amount of space as a Clan extra-light engine, allowing a light fusion "
				"engine-equipped 'Mech to survive the destruction of a side torso."
				"\n(Source: https://www.sarna.net/wiki/Light_fusion_engine)"
			);
			case Type_XL: return (
				"\c[White]The Extralight fusion engine (often shortened to XL engine) is mechanically similar to a "
				"fusion engine but uses much lighter radiation shielding. Replacing the dense tungsten carbide "
				"of standard fusion engines with a crystalline polymer similar to that of double heat sinks, "
				"the XL fusion engine is half the mass for the same performance."
				"\n(Source: https://www.sarna.net/wiki/Extralight_fusion_engine)"
			);
			case Type_XXL: return (
				"\c[White]The XXL engine weighs one-third as much as a standard fusion engine, "
				"but with some significant drawbacks in its present form. The XXL's light but bulky "
				"shielding technology takes up twice the space in side torso sections as an Inner Sphere "
				"or Clan XL engine of similar output, is three times as expensive as a comparable XL engine, "
				"and—most crippling—produces greatly increased heat. "
				"\n(Source: https://www.sarna.net/wiki/Extralight_fusion_engine)"
			);
		}
		return "";
	}
	
	override void GetShopProperties(out Array<String> stats, out Array<string> values)
	{	
		double MaxRating = 0.21;
		double speedRating = (187.5 / rating);
		
		stats.Push("EFFICIENCY");
		values.Push(String.Format("%.2f\%%", (maxRating / speedRating) * 100.0));	
	
		stats.Push("SIDE SLOTS");
		values.Push(String.Format("%d",blocks*blockSize));
		
		stats.Push("HEATSINKS");
		values.Push(String.Format("%d",floor(rating*0.04)));
	}
	
	double GetTonnage()
	{
		double std_index_tons[99] =
		{
			0.5,0.5,0.5,0.5,1.0,1.0,1.0,1.0,
			1.5,1.5,1.5,2.0,2.0,2.0,
			2.5,2.5,3.0,3.0,3.0,
			3.5,3.5,4.0,4.0,4.0,
			4.5,4.5,5.0,5.0,
			5.5,5.5,6.0,6.0,6.0,
			7.0,7.0,7.5,7.5,8.0,
			8.5,8.5,9.0,
			9.5,10.0,10.0,
			10.5,11.0,
			11.5,12.0,
			12.5,13.0,
			13.5,14.0,
			14.5,15.5,
			16.0,16.5,
			17.5,18.0,
			19.0,19.5,20.5,
			21.5,22.5,
			23.5,24.5,
			25.5,27.0,
			28.5,29.5,
			31.5,33.0,
			34.5,36.5,
			38.5,41.0,
			43.5,46.0,
			49.0,52.5,
			56.5,61.0,66.5,72.5,79.5,97.0,
			107.5,119.5,133.5,150.0,168.5,190.0,
			214.5,243.0,313.0,356.0,405.5,462.5
		};
		double tons = std_index_tons[floor(rating/5)-2];
		if(type == Type_STD    		) return tons;
		if(type == Type_Light  		) return roundTons(tons*0.75);
		if(type == Type_XL	   		) return roundTons(tons*0.50);
		if(type == Type_XXL    		) return roundTons(tons*0.33);
		return tons;
	}
	
	virtual double getPowerGeneration()
	{
		// Loosely based on fusion reaction power density.
		double tons = weight;
		double rad = 10.0;
		double particles = 1.69791; // quintillion(s)
		
		double gen = (3 * (particles*particles) * tons) / (4 * rad);
		
		if(type == Type_Light ) gen *= 0.8;
		if(type == Type_XL	  ) gen *= 1.5;
		if(type == Type_XXL   ) gen *= 2.0;
		return gen * 0.1;
	}
	
	int, int getRunWalkMP(DrivableMech mech, double hexSize = 30.0)
	{
		if(!mech) return 0, 0;
		
		int runMP = round( (getKPH(mech) / 10.8) * hexSize );
		int walkMP = ceil(runMP * 0.6);
		return runMP, walkMP;
	}
	
	virtual string getTypeStr()
	{
		switch(type)
		{
			case Type_STD:     return "STD";
			case Type_Light:   return "LIGHT";
			case Type_XL:      return "XL";
			case Type_XXL:     return "XXL";	
			default: return "STD";
		}
	}
	
	clearscope double getKPH(DrivableMech mech)
	{
		double baserating = 187.5; 
		return (32.4*(100./mech.maxWeight)) / (baserating/rating); 
	}
		
	clearscope static double speedToKPH(double spd)
	{
		double unitsPerSecond = spd * TICRATE;
		double unitsPerHour = unitsPerSecond * 3600.0;
		return (( unitsPerHour * UTOCM ) / 100000.0);
	}
	
	// Holy fuck this is a mess LMFAO
	const MOVEFRICMOD   = 0.94/DrivableMech.MECHFRICTION;
	const MOVEACCELREAL = 15.66666564814815 * MOVEFRICMOD;
	const MOVESPEED_MOD = 10 * MOVEFRICMOD; 
	clearscope static double getMechKPHSpeed(double KPH)
	{
		double unitsPerHour = (KPH*100000.0) / UTOCM;
		double unitsPerSecond = unitsPerHour / 3600.0;
		
		unitsPerSecond /= MOVESPEED_MOD;
		unitsPerSecond *= sv_mdr_mechspeedscale;
		
		return unitsPerSecond / TICRATE;
	}
	
	clearscope static double mechSpeedToKPH(double spd)
	{
		double kph = speedToKPH(spd);
		return kph * ((MOVESPEED_MOD/sv_mdr_mechspeedscale) / MOVEACCELREAL);
	}
	
	virtual void AutoDetectEngine()
	{
		// Find rating and type based on classname.
		// Naming convention -> MechEngine_ -> STD###, XL###, XXL###, LIGHT###
		Name engineType; int engineRating;
		[engineType, engineRating] = GetEngineName(getClassName());
		if(engineType == 'UNKNOWN ENGINE') 
		{
			console.printf("\c[Red]MechEngine Error: failed to autodetect engine parameters for %s.\c[White]", getClassName());
			return; // Unrecognized naming convention.
		}
		// console.printf("Rating for %s: [%d] %d :> Type is %s", clsName, ratingIndex, engineRating, engineType); 
		
		switch(engineType)
		{
			case   'STD': type = Type_STD;   break;
			case    'XL': type = Type_XL;    break;
			case   'XXL': type = Type_XXL;   break;
			case 'LIGHT': type = Type_Light; break;
		}
		rating = clamp(engineRating, 100, 500);
	}
	
	clearscope static string, int GetEngineName(class<MechEngine> engineClass)
	{
		string clsName = engineClass.getClassName();
		int engineToken = clsName.IndexOf("_");
		
		string nums = "0123456789";
		int ratingIndex = -1;
		for(uint i = 0; i <= clsName.Length(); i++)
		{
			string ch = String.Format("%c", clsName.ByteAt(i));
			if(nums.IndexOf(ch) != -1)
			{
				ratingIndex = i;
				break;
			}
		}
		
		// Unrecognized naming convention.
		if(engineToken == -1 || ratingIndex == -1) 
			return "UNKNOWN ENGINE", 0; 
				
		return clsName.Mid(engineToken+1, ratingIndex-engineToken-1), clsName.Mid(ratingIndex).ToInt();
	}
	
	override void Defaults()
	{	
		if(getClassName() != "MechEngine")
		{
			rating = 100;
			type = Type_STD;
			baseValue = 3065.67;
			AutoDetectEngine();
			SetupEngine();
			value = GetPrice();
		}
	}
	
	void SetupEngine()
	{
		// Setup engine blocks
		switch(type)
		{
			case Type_STD: // 6 + 0
				blocks = blockSize = 0;
			break;
		
			case Type_XL: // 6 + 6
				blocks = 1;
				blockSize = 3;
			break;
			
			case Type_Light: // 6 + 4
				blocks = 1;
				blockSize = 2;
			break;
			
			case Type_XXL: // 6 + 12
				blocks = 1;
				blockSize = 6;
			break;
		}
		
		size = 6;
		nosave = true;
		weight = GetTonnage();
		displayName = String.Format("%s ENGINE %d", getTypeStr(), rating);
	}
	
	override void OnAttach()
	{
		super.OnAttach();
		
		// Add engine blocks.
		let lt = parent.mech.leftTorso;
		let rt = parent.mech.rightTorso;  
		for(uint i = 0; i < blocks; i++) 
		{
			let lt_block = MechItem.Init("MechEngineBlock");
			lt_block.displayName = displayName;
			lt_block.size = blockSize ? blockSize : lt_block.size;
			if(lt_block.TryAttach(lt)) engineBlocks.push(lt_block);
			
			let rt_block = MechItem.Init("MechEngineBlock");
			rt_block.displayName = displayName;
			rt_block.size = blockSize ? blockSize : rt_block.size;
			if(rt_block.TryAttach(rt)) engineBlocks.push(rt_block);
		}
		
		// Add heatsinks to Engine
		int heatsinkAmt = floor(rating*0.04);
		
		for(int i = 0; i < heatsinkAmt; i++)
		{
			let heatsink = MechHeatsink(Init("MechDoubleHeatsink"));
			heatsink.parent = parent;
			heatsink.mech = mech;
			heatsink.OnAttach();
			heatSinks.Push(heatsink);
		}
	}
	
	override void OnDetach()
	{
		super.OnDetach();
	
		// Remove engine blocks.
		for(int i = 0; i < engineBlocks.Size(); i++)
		{
			let block = engineBlocks[i];
			if(block) block.TryDetach(forced:true);
		}
			
		// Remove heatsinks
		for(int i = 0; i < heatsinks.Size(); i++)
		{
			let heatsink = heatsinks[i];
			heatsink.OnDetach();
			heatsink.Destroy();
		}
		
		engineBlocks.Resize(0);
		heatsinks.Resize(0);
	}
	
	override int TryAttach(MechHardpoint part, bool forced)
	{
		if(part.mech.FindItem("MechEngine", true))
			return IAE_EXCLUSIVE;

		let engBlock = MechItem.Init("MechEngineBlock");
		int eblockSlots = blocks * (blockSize ? blockSize : engBlock.size);
		engBlock.Destroy();
		
		int engTotalSlots = size + (blocks*2) * blockSize;
		int freeSlots = MechDynamicStructure.getTotalFreeslots(part.mech);
	
		let lt = part.mech.leftTorso;
		let rt = part.mech.rightTorso;	
		
		if( (lt.slots +  eblockSlots) > lt.maxslots ||
			(rt.slots +  eblockSlots) > rt.maxslots ||
			freeSlots < engTotalSlots ) 
		{
			return IAE_NOSLOTS;
		}
		
		return super.TryAttach(part.mech.torso, forced);
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		
		double power = abs(mech.throttle);
		modifyHeat(0.16 * power);
		
		// Energy generation
		energy += getPowerGeneration() / double(TICRATE * 0.33);
		energy = clamp(energy, 0, 1.0);
		
		for(int i = 0; i < heatsinks.Size(); i++)
		{
			let heatsink = heatsinks[i];
			if(heatsink) heatsink.DoEffect();
		}
	}
}

class MechWeapon : MechItem
{
	int group;
	int fireTime;
	int cooldown;
	int cooldownTime;
	int ammoUse;
	int refire, refireCount, refireDelay, refireTimer; // Used for weapons which fire multiple times.
	bool firing;
	double minrange, range;
	double damage;
	double heat;
	string mountType;
	Sound fireSound;
	Actor homingTarget;
	HardpointMount mount;
	class<MechAmmo> ammoType;
	class<MechProjectile> projType;
	double energyUse;
	MechAmmo loadedAmmo;
	
	MechMountDeco mountDecoObject;
	class<MechMountDeco> mountDeco;
	double mountDecoScale;
	vector3 mountDecoOffs;
	vector3 fireOffs;
	

	override void GetUIColors(out int fontColor, out int bgColor)
	{
		let weap = MechWeapon(self);
		if(weap)
		{
			if(weap.mountType ~== "energy"   ) bgColor = 0xFFb0b009;
			if(weap.mountType ~== "ballistic") bgColor = 0xFF132891;
			if(weap.mountType ~== "missile"  ) bgColor = 0xFF186b13;
		}
	}
	
	override bool isEquipped(DrivableMech mech)
	{
		return !!parent && (mount || mountType == "NONE");
	}
	
	// Convert from spreadsheet data.
	virtual double convertHeat(double amt, double delta)
	{
		return (amt * 6.5) / delta;
	}
		
	virtual double convertDMG(double dmg, double delta)
	{
		return (dmg / MechHardpoint.DMGSCALE) / delta;
	}
	// --------------------------- \\
	
	override MechItem MakeCopy()
	{
		let item = MechWeapon(super.MakeCopy());
		item.group = group;
		return item;
	}
	
	virtual bool isGroupable()
	{
		// If false, this weapon cannot be assigned to any group.
		return true;
	}
	
	virtual bool checkSelectable()
	{
		return !checkDestroyed();
	}
	
	play virtual void A_Recoil(double pitchAmt, double pushBack = 0)
	{
		if( !mech || !MechTorso(mech.torso) || !mount ) return;
		
		// If we're on an Arm and this arm has upper actuation capability, arm will compensate for recoil.
		let arm = MechArm(mount.hardpoint);
		if(arm && arm.FindItem("MechUpperArmActuator", true))
		{
			arm.pitchOffs -= pitchAmt * 5;
			pitchAmt *= 0.33;
			pushBack *= 0;
		}
		
		MechTorso(mech.torso).pitchBobVel -= pitchAmt;
		
		if(pushBack)
		{
			pushBack *= cos(mech.angle-mech.torso.angle); // Adjust recoil so it's facing the torso direction.
			mech.vel -= DrivablesMath.VecFromAngles(mech.angle, mech.pitch, pushBack);
		}
	}
	
	virtual void WeapSound(Sound snd, double vol = 1.0, bool randomPitch = false)
	{
		if(parent) parent.A_StartSound(snd, CHAN_WEAPON, flags:CHANF_OVERLAP, volume:vol, pitch:randomPitch ? frandom[SFXRNG](0.6,1.0) : 0);
	}
	
	play virtual void reloadAmmo()
	{
		if(!ammoType || !parent) return;
		
		loadedAmmo = MechAmmo(parent.FindItem(ammoType));
		if(!loadedAmmo) 
			loadedAmmo = MechAmmo(parent.mech.FindItem(ammoType));
	}
	
	
	clearscope virtual int checkAmmo()
	{
		if(loadedAmmo && !loadedAmmo.parent) loadedAmmo = NULL;
		return !loadedAmmo ? 0 : loadedAmmo.curAmmo;
	}
	
	clearscope virtual int countAmmo()
	{
		if(!ammoType || !parent) return int.max;
		return parent.mech.countAllAmmo(ammoType);
	}
	
	// minrange, optimal range, maximum range
	clearscope virtual double, double, double getRanges()
	{
		double maxRange = 0;
		if(!projType) return 0,0,0;
		let projDefs = GetDefaultByType(projType);
		
		if(projDefs) maxrange = projDefs.maxRange;
				
		return minrange, range, maxrange;
	}
	
	play virtual void preFire()
	{
		// Called when fire button is pressed on this weapon or weapon group.
	}
	
	clearscope virtual bool canFire()
	{
		bool ammoCheck = ammoUse <= 0 || countAmmo() >= ammoUse;
		bool energyCheck = energyUse <= 0 || (mech.engine && mech.engine.energy >= energyUse);
		return ammoCheck && energyCheck;
	}
	
	play virtual void depleteAmmo(int amt)
	{
		if(checkAmmo() <= 0) reloadAmmo();
		if(loadedAmmo) loadedAmmo.curAmmo -= amt;
		
		double criticalAmmo = ammoUse*3.0;
		double ammoAmount = countAmmo();
		double prevAmmoCount = ammoAmount + amt;
		
		if(prevAmmoCount > 0 && ammoAmount <= 0)
		{
			if(sndItemName) mech.betty.Push(sndItemName);
			mech.betty.Push("Betty/Ammo/Depleted");
		}
		else if(prevAmmoCount > criticalAmmo && ammoAmount <= criticalAmmo)
		{
			if(sndItemName) mech.betty.Push(sndItemName);
			mech.betty.Push("Betty/Ammo/Critical");
		}
	}
	
	play virtual void SetGroup(uint grp, bool onoff)
	{
		uint gBit = 2**(grp-1);
		if(onoff) 
			group |= gBit;
		else
			group &= ~gBit;
	}
	
	override int TryAttach(MechHardpoint part, bool forced)
	{
		bool noMount = mountType == "NONE"; // This weapon doesn't have a mount position.		
	
		// Attempt to find position to mount weapon to.
		let mnt = part.findMountPoint(mountType);
		if(!mnt && !noMount) return IAE_INVALID;
		
		int success = super.TryAttach(part, forced);
		if(success == IAE_SUCCESS && !noMount)
		{
			mnt.mountItem(self);
			mount = mnt;
			OnMount();
		}

		return success;
	}
	
	virtual vector3 getFirePos()
	{
		double offsScale = mount ? mount.decoScale : 1.0;
		if(!offsScale) offsScale = 1.0;
		
		return mount.getPos() + (fireOffs * parent.scale.X * offsScale);
	}
	
	override void OnInventoryAdd(I_MechItemStorage destInv)
	{
		super.OnInventoryAdd(destInv);
		group = 1; // Reset weapon groupings
	}
	
	override void Repair(int amt)
	{
		bool destroyed = hp <= 0;
		super.Repair(amt);
		
		// If weapon was previously destroyed but is now repaired, re-mount our decoration.
		if(destroyed && hp > 0) OnMount();
	}
	
	play virtual MechMountDeco OnMount()
	{
		// Setup mount deco if defined.
		if(!mountDeco) return NULL;
		mountDecoObject = MechMountDeco.Attach(self, mountDeco);
		
		return mountDecoObject;
	}
	override void OnDetach()
	{
		super.OnDetach();
		if(mount) mount.unmountItem(); // Clear mech mount point.
	}
	
	clearscope virtual double getCooldownTime()
	{
		return cooldownTime + fireTime;
	}
	
	play static void FireWeapons(Array<MechWeapon> weaps, Array<MechWeaponGroup> groups, uint grp = 0, bool instantFire = false)
	{		
		let group = grp > 0 ? groups[grp-1] : NULL;
		bool chainfire = grp > 0 ? groups[grp-1].chainfire : false;
		
		// If weapon was removed from the group, discard reference to it.
		if(group.prevWeapFired && weaps.Find(group.prevWeapFired) == weaps.Size())
			group.prevWeapFired = NULL;
		
		for(int i = 0; i < weaps.Size(); i++)
		{	
			let weap = weaps[i];
			let hardpoint = weap.parent;
			if(!hardpoint || !weap) continue;
			if(weap.checkDestroyed()) continue; // Cannot fire destroyed weapons.
			
			// Fire in chainfire.
			if( chainfire && group ) 
			{
				bool fireWait = !instantFire && group.weapCycle > 0;
				if( (!group.prevWeapFired || group.prevWeapFired == weap) && !fireWait )
				{
					int curIndex = i;
					let nextWeap = weaps[(i+1)%weaps.Size()];
					
					if(group.prevWeapFired)
					{
						weap = nextWeap;
						hardpoint = weap.parent;
						curIndex++;
					}
					// console.printf("Firing (Chainfire): %s on %s (%d)", weap.getClassName(), weap.parent.getClassName(), curIndex);
					
					weap.preFire();
					if( weap.canFire() && weap.cooldown <= 0 && weap.mount && weap.Fire(weap.getFirePos()) )
					{
						// Alert monsters
						if(weap.mech.driver)
							weap.mech.driver.A_AlertMonsters(1024);
						
						weap.modifyHeat(weap.heat);
						weap.modifyEnergy(weap.energyUse);
						weap.cooldown += weap.getCooldownTime();
						group.weapCycle = weap.fireTime;
						group.prevWeapFired = weap;
					}
					else
					{
						group.prevWeapFired = weap; // Skip weapon if we cannot fire it.
					}
					
					break;
				}
				continue;
			}
			
			// Fire normally
			weap.preFire();
			if( weap.canFire() && weap.cooldown <= 0 && weap.mount && weap.Fire(weap.getFirePos()))
			{
				// Alert monsters
				if(weap.mech.driver)
					weap.mech.driver.A_AlertMonsters(1024);
			
				weap.modifyHeat(weap.heat);
				weap.modifyEnergy(weap.energyUse);
				weap.cooldown += weap.getCooldownTime();
				group.weapCycle = weap.fireTime;
			}
		}
	}
	
	override void Defaults()
	{
		super.Defaults();
		group = 1;
	}
	
	virtual bool DoRefire()
	{
		refire = refireCount;
		refireTimer = refireDelay;
		return true;
	}
	
	override void DoEffect()
	{
		super.DoEffect();
		if(cooldown) cooldown--;
		
		// Refire logic
		if(--refireTimer <= 0 && refire > 0)
		{
			if(canFire() && Fire(getFirePos()) )
			{
				refireTimer = refireDelay;
				refire--;
			}
			else
				refire = 0;
		}
		
		// Update target
		if(mech.targetProgress >= 1.0) 
			homingTarget = mech.curTarget; 
		else if(mech.targetProgress <= 0.1 && homingTarget)
			homingTarget = NULL;
	}
		
	// Note: firePos is ALWAYS relative offsets from the parent's position
	// to get absolute positions, use parent.OffsetPos(firePos.x,firePos.y,firePos.z)
	play virtual bool Fire(vector3 firePos)
	{
		if(cooldown) return false;
		// Pew pew pew
		return true;
	}
}

// Info about this weapon grouping.
class MechWeaponGroup : Object
{
	MechWeapon prevWeapFired;
	uint weapCycle; // Timer for weapon cycling.
	bool chainfire;
	
	virtual MechWeaponGroup MakeCopy()
	{
		let grp = new("MechWeaponGroup");
		grp.prevWeapFired = prevWeapFired;
		grp.weapCycle = weapCycle;
		grp.chainfire = chainfire;
		return grp;		
	}
	
	virtual void DoEffect()
	{
		if(weapCycle) weapCycle--;
	}
}

// Inventory item for storing mechitems
class I_MechItemStorage : Inventory
{
	double cbills; // Player's money
	Array<MechItem> items;
	Array<MechItem> shopItems;
	string dropshipNextMap; // Map to return to after dropship.
	
	Default
	{
		Inventory.MaxAmount 1;
		+INVENTORY.UNDROPPABLE;
	}
	
	clearscope void FindItems(class<MechItem> itemCls, Array<MechItem> result, bool subclass = false)
	{
		foreach(item : items)
		{
			if(item.IsTypeOf(itemCls, subclass))
				result.Push(item);
		}
	}
	
	clearscope MechItem FindItem(class<MechItem> itemCls, bool subclass = false)
	{
		foreach(item : items)
		{
			if(item.IsTypeOf(itemCls, subclass))
				return item;
		}
		return NULL;
	}
	
	MechItem takeItem(int index, bool deplete = true)
	{
		let item = items[index];
		if(item.infinite) return item.MakeCopy();

		MechItem output = (item.amount > 1) ? item.MakeCopy() : item;	
		if(deplete) depleteItem(item);
		
		return output;
	}	
	
	void depleteItem(MechItem item, int amt = 1)
	{	
		if(item.infinite) return;
		if(item.amount > amt) 
			item.amount -= amt;
		else
		{
			int index = items.Find(item);
			if(index != items.Size()) items.Delete(index);
		}
	}
		
	void AddItem(MechItem item, int amt = 1)
	{
		for(int i = 0; i < amt; i++) AddNewItem(item);
	}
	
	void AddNewItem(MechItem item)
	{
		Array<MechItem> validItems;
		FindItems(item.getClass(), validItems);
		
		for(int i = 0; i < validItems.Size(); i++)
		{
			let stackItem = validItems[i];
			if(stackItem && stackItem.CanStack(item))
			{
				if(!item.infinite) stackItem.amount++;
				return; // Successfully stacked item.
			}
		}
		
		item.OnInventoryAdd(self);
		items.Push(item);
	}
	
	static I_MechItemStorage Get(Actor from, bool give = true)
	{
		let itm = I_MechItemStorage(from.FindInventory("I_MechItemStorage"));
		if(!itm && give)
		{
			from.GiveInventory("I_MechItemStorage", 1);
			itm = I_MechItemStorage(from.FindInventory("I_MechItemStorage"));
			
			// Add essential items.
			foreach(cls : AllClasses) 
			{
				let item = (class<MechItem>)(cls);
				if(!item) continue;
				
				let itemInstance = MechItem.Init(item);
				if(itemInstance && itemInstance.essential)
					itm.AddItem(itemInstance);
				else if(itemInstance)
					itemInstance.Destroy();
			}
			
			// Debug: give all items
			foreach(cls : AllClasses)
			{
				let item = (class<MechItem>)(cls);
				if(!item) continue;

				let itemInstance = MechItem.Init(item);
				if( itemInstance && (!itemInstance.movable || itemInstance.displayName == "") )
				{
					itemInstance.Destroy();
					continue;
				}
								
				// Give 25 of each item.
				if(itemInstance) 
				{
					let shopInstance = itemInstance.MakeCopy();
					itm.shopItems.Push(shopInstance);
					
					// Randomly add items for the player
					if(random[startItemsRNG](0,100) >= 75)
						itm.AddItem(itemInstance, random[startItemsRNG](1,20));	
				}
			}
			
			itm.cbills = 12345660;
		}
		
		return itm;
	}
}

class I_DontStack : Inventory
{
	override bool HandlePickup (Inventory item)
	{
		if (item.GetClass() == GetClass()) return false;
		return super.HandlePickup(item);
	}	
}