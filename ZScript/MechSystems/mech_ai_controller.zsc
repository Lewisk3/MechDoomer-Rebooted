class MechAIControllerBase : Actor abstract
{
	class<DrivableMech> mechType;
	DrivableMech mech;
	DrivableMech targetMech;
	
	MechCockpit head;
	MechTorso torso;
	MechArm leftArm, rightArm;
	MechSideTorso leftTorso, rightTorso;
	MechLeg leftLeg, rightLeg;
	
	Property MechType : mechType;

	Default
	{
		+NOINTERACTION;
		MechAIControllerBase.MechType "NONE";
	}
	
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		SetupMech(mechType);
	}
	
	void SetupMech(class<DrivableMech> mechType)
	{
		if(!mechType) return;
		let spMech = DrivableMech(Spawn(mechType, pos));
		mech = spMech;
		mech.angle = angle;
	}
	
	virtual void SimpleTick()
	{
		if (isFrozen()) return;
			
		//animation:
		if (tics != -1) 
		{
			if(tics > 0) tics--;
			while (!tics) 
				if(!SetState(CurState.NextState)) return;
		}
	}
	
	double getMeterDistance(double units)
	{
		return DrivableMech.unitsToKM(units) * 1000;
	}
	
	// Returns aim difference.
	double AimTowards(vector3 aimPos, vector3 armAimPos, double rate = 1.0, bool aimTorso = true, bool aimLeft = true, bool aimRight = true)
	{		
		vector3 lookingPos = Quat.FromAngles(mech.torso.angle, mech.torso.pitch, 0) * (mech.torso.radius, 0, 0);
		lookingPos = level.vec3offset(mech.torso.pos, lookingPos);
		
		vector3 coords = level.SphericalCoords(lookingPos, aimPos, (angle, pitch));
		if(aimTorso)
		{
			angle -= (coords.x * rate);
			pitch -= (coords.y * rate);
		}
		
		let leftArm = MechArm(mech.leftArm);
		let rightArm = MechArm(mech.rightArm);
		if(aimLeft) leftArm.AimAt(armAimPos);
		if(aimRight) rightArm.AimAt(armAimPos);
		
		return (abs(coords.x) + abs(coords.y));
	}
	vector3 GetMoveTowards(vector3 movePos)
	{
		vector3 walkingPos = Quat.FromAngles(mech.angle, 0, 0) * (1, 0, 0);
		walkingPos = level.vec3offset(mech.pos, walkingPos);
		
		vector3 coords = level.SphericalCoords(walkingPos, movePos, (mech.angle, 0));
		coords.x *= -1;
		double dist = coords.z;
		
		if(abs(coords.x) > 5)
		{
			if(coords.x < 0) return ( 1, coords.x, dist);
			if(coords.x > 0) return (-1, coords.x, dist);
		}
		
		return (0, coords.x, dist);
	}
	
	void DoJumpjet(bool onoff)
	{
		Array<MechItem> jets;
		mech.FindAllItems("MechJumpJet", true, jets, skipDestroyed:true);
		if(jets.Size())
		{
			foreach(jetItem : jets) 
			{
				let jet = MechJumpJet(jetItem);
				if(jet) jet.SetJetState(onoff, checkFuel:true);
			}
		}
	}
	
	// Returns weapons that can be used at the current range, and that can hit the target.
	// Returns optimal ranges (minRange, avgRange);
	vector2 GetValidWeapons(double targetDist, vector3 aimTarget, double inaccuracy, out Array<MechWeapon> validWeapons)
	{
		double distMeters = getMeterDistance(targetDist);
		Array<MechWeapon> weapons; 
		mech.GetAllWeapons(weapons);
		
		double optMinRange, optAvgRange, totalRange;

		// Get Target Lock
		if(mech.curTarget != target) 
			mech.DoLockOnTarget(target);
	
		int iterations = 0;
		foreach(weap : weapons)
		{
			if(!weap) continue;
			let laserWeap = MechLaserWeapon(weap);
			let mislWeap = MechMissileWeapon(weap);
			if(weap.CheckDestroyed() || weap.countAmmo() < weap.ammoUse || !weap.checkSelectable()) continue;
			
			let weapProj = laserWeap ? NULL : GetDefaultByType(weap.projType);
			
			double minRange = laserWeap ? 0 : weapProj.minRange;
			double maxRange = laserWeap ? laserWeap.laserRange : weapProj.maxRange;
			if( (optMinRange <= 0 && minRange > 0) || optMinRange < minRange)
				optMinRange = minRange;
				
			totalRange += maxRange;
			iterations++;
			
			if(distMeters < minRange || distMeters > maxRange) continue;
			
			// For all missile weapons, if they require lock and don't have it, discard them.
			bool isHoming = mislWeap && weapProj && weapProj.hasHoming;
			if(isHoming && mech.targetProgress < 1.0) continue;
			
			// Determine if the weapon can hit the target.
			let hardpoint = weap.mount.hardpoint;
			vector3 aimFrom = hardpoint.lookingPos;
			vector3 aimTo = level.sphericalCoords(aimFrom, aimTarget, (hardpoint.angle,hardpoint.pitch));
			double aimDist = aimTo.z;
			bool canHit = false;

			double angTo = aimTo.x;
			double pitTo = aimTo.y;
			
			// If we're homing, assume always hit.
			if(isHoming) canHit = true; 
			
			// Check if aim is with-in range.
			if(!canHit && (abs(angTo) <= inaccuracy && abs(pitTo) <= inaccuracy)) 
			{
				// Check if weapon can actually hit without being obstructed.		
				FLineTraceData lt;
				let [hitPos, hitAct] = DrivablesMath.AimFrom(
					hardpoint, aimFrom, 
					hardpoint.angle - angTo, 
					hardpoint.pitch - pitTo
				);
				if(hitAct == target) canHit = true;
			}
			
			if(canHit) validWeapons.push(weap);
		}
		
		optAvgRange = totalRange / iterations;
		return (optMinRange, floor(optAvgRange));
	}
	
	virtual void OnMechDestroyed()
	{
		// Get rid of controller if the mech it's attached to is dead.
		mech.RemovePilot();
		Destroy();
	}
	
	override void Tick()
	{
		SimpleTick();
		if(!mech) return;
		
		if(mech.getAge() < 2) return;
		if(!mech.driver) mech.TakePilot(self);
		
		if(mech.CheckMechDestroyed())
		{
			OnMechDestroyed();
			return;
		}
				
		// Grab mech parts.
		head = MechCockpit(mech.head);
		leftArm = MechArm(mech.leftArm);
		rightArm = MechArm(mech.rightArm);
		leftTorso = MechSideTorso(mech.leftTorso);
		rightTorso = MechSideTorso(mech.rightTorso);
		torso = MechTorso(mech.torso);
		leftLeg = MechLeg(mech.leftLeg);
		rightLeg = MechLeg(mech.rightLeg);
		
		AIThink(mech.checkPoweredUp());		
	}
	
	virtual void AIThink(bool poweredup)
	{
		// Used for child classes, AI Logic.
	}
	
	States
	{
		Spawn:
			TNT1 A -1;
		stop;
	}
}