/*
	How was this constant found?
	First, a Hellbringer is placed in a map then a pillar
	is placed next to it, the pillar is then risen until it matches
	the Hellbringer's observed height.
	
	This number is derrived like so
	HellBringer = 12.9m, 92 units.
	
	12.9m / 92.0u = ~0.14 meters a unit.
	
	If we compare Doomguy instead, at an assumed height of ~1.70 meters
	we get; 3.039047882723666
*/

const UTOCM_Scaled = ((12.9 / 92.0) * 100.0);
const UTOCM_Real = UTOCM_Scaled / 5.54;
const UTOCM = UTOCM_Scaled;
const MECHPRICESCALAR = 0.5;

class DrivableMech : DrivableObject
{
	const MECHFRICTION = 0.94;
	double angVel, legVel;
	double throttle, accel, accelKPH, decelKPH;
	double curHeat, maxHeat, maxKelvin;
	double moveSpeed, moveSpeedKPH;
	double weight, maxWeight;
	int powerupCycleTics; // Tics to full powerup.
	double selectedWeapon, selectedGroup; // For UI stuff.
	double healthPerc; // Health percent taking into account all hardpoints.
	int saveID; // Used for saving mechs to the correct location.
	bool noItemSlots; // If true, prevents any items from being equipped.
	bool inCombatZoom; // If true, combat zoom is active.
	double combatZoomScale; // Multiplied by desiredFOV.
	MechChassisStructure chassisStructure;
	string MechItemGraphic; // UI Graphic for mech.
	double mechvalue; // Mech cbill value;
	string manufacturer; // Used for UI properties.
	
	double prevThrottle; // Man I hate doing acceleration sounds...
	double cachedScale, cachedAutoFit; // Cache of sv_mdr_mechscale CVar.

	double EMI; // TODO: Electro-Magnetic interferrence, affects the HUD and targetting computer depending on how much interference is present.

	MechWeapon prevWeapFired;
	MechArmor armorType;
	Array<MechWeaponGroup> weaponGroups;
	Actor exitedPilot; // Holds the driver after they exit, used to prevent getting stuck after exiting.
	
	vector3 aimingPos;
	
	// Sound logic
	SoundQueue betty;
	
	// UI Stuff
	string paperdoll_Background, paperdoll_Outline;
	string mechChassisName, mechVariantName;
	
	// Shutdown stuff
	uint shutdownTimer, powerupTimer;
	bool shutdown, heatWarn, heatCritical, heatShutdown, overrideShutdown;
	
	// Locks aim such that only arms or torso can move.
	bool armLock, torsoLock; 
	bool centerToTorso, centerToLegs;
	
	// Targeting
	double targetProgress; // 1.0 when target is locked.
	Actor curTarget; // Targeted enemy, not necessarily locked.
	
	MechPart legs, hips; // Non-hardpoint parts.
	MechHardpoint torso, leftTorso, rightTorso, leftArm, rightArm, head, leftLeg, rightLeg;
	MechEngine engine;
	
	ThirdpersonCamera camDrone;
	DrivableComponent camActive;
	
	// Used to specify if mech needs more specific data storage, when mech is saved to player Inventory.
	class<MechSaveData> saveDataType;
	class<VehicleHUD> HUDType;
	
	// UI
	ui VehicleHUD activeHUD; // Mech's currently active HUD. 
	
	// Data management
	I_SaveMechData MechSerializer;
	
	// If not NULL, the mech will automatically take this pilot upon creation.
	// Set to NULL after pilot is taken.
	Actor autoTakePilot; 
	
	Property Acceleration : accelKPH, decelKPH;
	Property MaxHeat : maxHeat, maxKelvin;
	Property MaxWeight : maxWeight;
	Property PaperdollBG : paperdoll_Background, paperdoll_Outline;
	Property SaveDataFormat : saveDataType;
	Property ChassisName : mechChassisName;
	Property VariantName : mechVariantName;
	Property HUD_Class : HUDType;	
	Property CombatZoom : combatZoomScale;
	Property ItemGraphic : MechItemGraphic;
	Property CBillValue : mechvalue;
	Property Manufacturer : manufacturer;
	
	enum MechBtns
	{
		BT_GROUPNEXT  = 1 << 0,
		BT_GROUPPREV  = 1 << 1,
		BT_WEAPNEXT   = 1 << 2,
		BT_WEAPPREV   = 1 << 3,
		BT_GROUPSET   = 1 << 4,
		BT_GROUPCHF   = 1 << 5,
		BT_STOPMECH   = 1 << 6,
		BT_ALIGNLEGS  = 1 << 7,
		BT_ALIGNTORSO = 1 << 8,
		BT_TORSOLOCK  = 1 << 9,
		BT_ARMLOCK    = 1 << 10,
		BT_GETTARGET  = 1 << 11,   
		BT_PEEKINV    = 1 << 12,
		BT_POWERCYCLE = 1 << 13,
		BT_OVRSHUTDWN = 1 << 14,
		BT_WEAPONSTATE = 1 << 15, // Toggles state of weapon; might be used to switch ammo-types for example.
		BT_ITEMMAGNET  = 1 << 16,
		BT_DRONEREPAIR = 1 << 17
	};
	
	enum GroupBits
	{
		GROUPFLG_ONE   = 1,
		GROUPFLG_TWO   = 1 << 1,
		GROUPFLG_THREE = 1 << 2,
		GROUPFLG_FOUR  = 1 << 3,
		GROUPFLG_FIVE  = 1 << 4
	};
	
	// CVars
	transient CVar cv_throttleDecay;
	transient CVar cv_run;
	transient CVar cv_analogthrottle;
	
	Default
	{
		-SHOOTABLE;
		-SOLID;
		
		Radius 16;
		Height 56;
		Gravity 0.25;
		Scale 1.0;
		MaxStepHeight 36;
		DrivableMech.Acceleration 25, 30; 
		DrivableMech.MaxWeight 85; // In Tons.
		DrivableMech.MaxHeat 200, 1050.0;
		DrivableMech.PaperdollBG "Graphics/HUD/Paperdoll/paperdoll_background.png", "Graphics/HUD/Paperdoll/paperdoll_thickOutline.png";
		DrivableMech.SaveDataFormat "MechSaveData";
		DrivableMech.HUD_Class "MechHUD";
		DrivableMech.CombatZoom 0.1;
		DrivableMech.Manufacturer "Unknown";
	}
	
	override void PreTravelled()
	{
		super.PreTravelled();
		
		// Save mech to serializer
		if(MechSerializer) MechSerializer.SaveMechData(self);
	}
	
	clearscope virtual string GetWeightClass()
	{
		if(maxWeight > 100) return "Super-Heavy";
		if(maxWeight >= 80) return "Assault";
		if(maxWeight >= 60) return "Heavy";
		if(maxWeight >= 40) return "Medium";
		if(maxWeight >= 20) return "Light";
		return "Super-Light";
	}
	
	clearscope virtual string GetShopDescription()
	{
		return "Mech has no description.";
	}
	
	clearscope virtual void GetShopProperties(out Array<String> stats, out Array<string> values)
	{
		stats.Push("Class");
		values.Push(GetWeightClass());
		
		stats.Push("Tonnage");
		values.Push(String.Format("%d", maxWeight));
		
		stats.Push("Top Speed");
		values.Push(String.Format("%.2f", engine.getKPH(self)));
		
		stats.Push("Manufacturer");
		values.Push(manufacturer);
	}

	override void PostBeginPlay()
	{
		// Setup sounds
		betty = SoundQueue.Create();
	
		// Populate default arrays
		for(int i = 0; i < 5; i++)
			weaponGroups.Push(new("MechWeaponGroup"));
		
		super.PostBeginPlay();
				
		// Structure
		MechChassisStructure.AddToMech(self, "MechChassis_Standard");
				
		// Equip stuff
		SetupItems();
			
		// Autoscale
		cachedAutoFit = getAutoFitScale();
		cachedScale = getMechScale();
		A_SetScale(Scale.X * cachedAutoFit * cachedScale); 
		
		// Start shutdown
		shutdown = true;
		
		// Default selection
		selectedWeapon = 1;
	}
	
	virtual string getHardpointTypeName(MechHardpoint hp)
	{
		// Ugly but, works.
		// Needed for overriding if our mech is for example a Tank or helicopter.
		
		string pName = "None";
		if(hp == torso) pName = "Torso";
		if(hp == leftTorso) pName = "LeftTorso";
		if(hp == rightTorso) pName = "RightTorso";
		if(hp == leftArm) pName = "LeftArm";
		if(hp == rightArm) pName = "RightArm";
		if(hp == head) pName = "Head";
		if(hp == leftLeg) pName = "LeftLeg";
		if(hp == rightLeg) pName = "RightLeg";
		
		return pName;
	}
	
	virtual double getAutoFitScale()
	{
		// Determine mech's maximum height
		double maxHeight = 92;
		for(int i = 0; i < parts.Size(); i++)
		{
			let part = parts[i];
			let hp = MechHardpoint(parts[i]);
			double curHeight = part.pos.z + part.height;
			if(hp && hp.hitboxHeight > 0)
				 curHeight = max(curHeight, hp.pos.z + hp.hitboxPos_UD + hp.hitboxHeight);
			
			if(curHeight > maxHeight) maxHeight = curHeight;
		}
		
		// Attempt to determine desired mech scale, in reference to default player height.
		double doomguyHeight = 56 * level.pixelstretch;
		return doomguyHeight / maxHeight;
	}
	
 	clearscope virtual double, double getMechSize()
	{
		double maxHeight = 0;
	
		double curRadius;
		foreach(part : parts)
		{
			let hp = MechHardpoint(part);
			double curHeight = 0;
	
			if(hp)
			{
				curHeight = hp.pos.z + hp.height;
				if(hp.hitboxHeight > 0) 
					curHeight = max(curHeight, hp.pos.z + hp.hitboxPos_UD + hp.hitboxHeight);		
			}
		 
			if(maxHeight < curHeight) maxHeight = curHeight;
		
			curRadius += part.radius;
		}
		return curRadius, maxHeight;
	}
	
	virtual double GetMechScale()
	{
		// Dropship map has a fixed mechscale.
		Name mapname = level.mapname;
		if(mapname == 'DROPSHIP') return 3.0;
		
		return sv_mdr_mechscale;
	}
	
	virtual void AcquireTarget(bool requireSight = true)
	{
		let it = ThinkerIterator.Create();
		Actor act;
		double angleDist = double.infinity;
		LookExParams look;
		look.FOV = 30;
		
		while(act = Actor(it.Next()))
		{
			if(!act.bSHOOTABLE || act.bNODAMAGE) continue;
			if(!cam.IsVisible(act, false, look) && requireSight) continue;
			if(act == driver) continue;
			
			let hardpoint = MechHardpoint(act);
			let hitBox = MechHitBox(act);
			if(hardpoint && hardpoint.mech == self || hitBox && MechHardpoint(hitBox.parent).mech == self) continue;
			
			// Redirect hitbox to source mech, if target candidate.
			if(hardpoint) act = hardpoint.mech;
			if(hitBox) act = MechHardpoint(hitbox.parent).mech;
			
			vector3 diff = level.vec3Diff(head.pos, act.pos);
			double actualAngleTo = abs(Normalize180(atan2(diff.y, diff.x) - head.angle));
			double curAnglesDist = actualAngleTo + abs( (act.pos.z+act.height*0.5) - head.lookingPos.z );
			if(curAnglesDist < angleDist)
			{
				angleDist = curAnglesDist;
				curTarget = act;
			}
		}
	}
	
	virtual void HandleHoming(Array<MechWeapon> weaps)
	{
		double targetDecay = 0.80;
		double targetSpeed = 0.03;
		bool hasHomingWeapon = false;
		
		for(int i = 0; i < weaps.Size(); i++)
		{
			let curweap = weaps[i];
			let proj = curweap.projType;
			if(!proj) continue;
			
			let defs = GetDefaultByType(proj);
			if(defs.hasHoming) hasHomingWeapon = true;
		}

		if(!hasHomingWeapon || !curTarget) 
		{
			targetProgress *= targetDecay;
			return;
		}
	
		// Check if aim is with-in target range.
		vector3 diff = level.vec3Diff(head.pos, curTarget.pos);
		double angTo = abs(Normalize180(atan2(diff.y, diff.x) - head.angle));
		double zTo = abs( (curTarget.pos.z+curTarget.height*0.5) - head.lookingPos.z );
		
		if(angTo > 25 || zTo > 200 || EMI >= 50) 
		{
			targetProgress *= targetDecay;
			return;
		}
		else
		{
			if(targetProgress < 1.0) DoCockpitSound("Mech/Target/Locking", flags:CHANF_NOSTOP, volume:0.3);
			if(targetProgress < 1.0 && targetProgress + targetSpeed >= 1.0) 
				DoCockpitSound("Mech/Target/Locked");
				
			targetProgress = min(1.0, targetProgress + targetSpeed); 
		}
	}
	
	virtual void FetchCVars()
	{
		if(!driver.player) return;
		cv_throttleDecay = CVar.GetCVar("cl_mdr_throttledecay", driver.player);
		cv_run = CVar.GetCVar("cl_run", driver.player); 
		cv_analogthrottle = CVar.GetCVar("cl_mdr_analogthrottle", driver.player); 
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		if( other == driver || other == exitedPilot ) return false;
		return super.CanCollideWith(other, passive);
	}
	
	override void TakePilot(Actor user)
	{
		if(head && head.healthPoints <= 0)
		{
			console.printf("\c[Red]Mech's cockpit was destroyed!");
			return;
		}
		
		super.TakePilot(user);
		driverOffset.z = 60 * Scale.X;
		driver.A_SetScale(0,0);
		driver.A_SetSize(8,8);
		driver.angle = torso.angle;
		FetchCVars();
		
		if(cam)
		{
			if(!camActive) camActive = cam;
			SetDriverCamera(camActive);
		}
		
		// Setup mech save data
		if(!driver.FindInventory("I_SaveMechData"))
			driver.GiveInventory("I_SaveMechData", 1);
		
		// Save mech
		MechSerializer = I_SaveMechData(driver.FindInventory("I_SaveMechData"));
		if(MechSerializer) 
		{
			MechSerializer.SaveMechData(self);
			MechSerializer.lastPilotedMech = self;
		}
		
		// Update UseRange
		if(PlayerPawn(driver)) PlayerPawn(driver).UseRange = 128;
	}
	override void RemovePilot()
	{
		if(!shutdown && !sv_mdr_exitanytime)
		{
			console.printf("\c[Red]Mech must be shutdown before exiting.\c[White]");
			return;
		}
		
		// TODO: Think of a way to do multiplayer compatibility so mech's aren't
		// duplicated between players.
		
		// Save mech data
		if(MechSerializer) MechSerializer.SaveMechData(self);
	
		exitedPilot = driver;
		driver.SetOrigin(OffsetPos(30,0,0), true);
		driver.A_SetScale(driver.default.Scale.X, driver.default.Scale.Y);
		driver.A_SetSize(driver.default.Radius, driver.default.Height);
		if(camActive != cam) SetDriverCamera(driver);
		camActive = NULL;
		
		let driverPlr = PlayerPawn(driver);
		if(driverPlr) driverPlr.UseRange = driverPlr.Default.UseRange;
		
		super.RemovePilot();
	}
	
	clearscope virtual void getAllWeapons(out Array<MechWeapon> weaps, uint grp = 0, bool sorted = true, bool readDeadHardpoints = false)
	{
		if(!sorted)
		{
			for(int p = 0; p < parts.Size(); p++)
			{
				let hardpoint = MechHardpoint(parts[p]);
				if(!hardpoint || (hardpoint.healthPoints <= 0 && !readDeadHardpoints) ) continue;
				
				hardpoint.getWeapons(weaps, grp, ignoreDead:readDeadHardpoints);
			}
			return;
		}
		
		// Get sorted weapons
		if(leftArm) leftArm.getWeapons(weaps, grp, ignoreDead:readDeadHardpoints);
		if(rightArm) rightArm.getWeapons(weaps, grp, ignoreDead:readDeadHardpoints);
		if(head) head.getWeapons(weaps, grp, ignoreDead:readDeadHardpoints);
		if(leftTorso) leftTorso.getWeapons(weaps, grp, ignoreDead:readDeadHardpoints);
		if(torso) torso.getWeapons(weaps, grp, ignoreDead:readDeadHardpoints);
		if(rightTorso) rightTorso.getWeapons(weaps, grp, ignoreDead:readDeadHardpoints);
	}
	
	clearscope virtual void FindAllItems(class<MechItem> type, bool subclass, out Array<MechItem> foundItems)
	{
		for(int p = 0; p < parts.Size(); p++)
		{
			let hardpoint = MechHardpoint(parts[p]);
			if(!hardpoint || hardpoint.healthPoints <= 0) continue;
			
			hardpoint.findAllItems(type, subclass, foundItems);
		}
	}
	
	clearscope virtual uint, uint getSlotCount()
	{
		uint usedSlots, maxSlots;
		for(int p = 0; p < parts.Size(); p++)
		{
			let hardpoint = MechHardpoint(parts[p]);
			if(!hardpoint || hardpoint.healthPoints <= 0) continue;
			
			usedSlots += hardpoint.slots;
			maxSlots += hardpoint.maxSlots;
		}
		
		return usedSlots, maxSlots;
	}
		
	clearscope virtual int countAllAmmo(class<MechAmmo> type)
	{
		Array<MechItem> ammos;
		FindAllItems(type, false, ammos);
		
		int totalAmmo = 0;
		for(int i = 0; i < ammos.Size(); i++)
			totalAmmo += MechAmmo(ammos[i]).curAmmo;
		
		return totalAmmo;
	}
	
	virtual void FireWeapons(uint grp = 0, bool instantFire = false)
	{
		Array<MechWeapon> weaps;
		getAllWeapons(weaps, grp);
		MechWeapon.FireWeapons(weaps, weaponGroups, grp, instantFire);
	}
	
	// Wrappers for readability.
	virtual MechPart AddMechPart(class<MechPart> part, double fw, double lr, double ud, DrivableComponent parent)
	{
		return MechPart(AddPart(part, fw,lr,ud, parent));
	}
	virtual MechHardpoint AddHardpoint(class<MechHardpoint> part, double fw, double lr, double ud, DrivableComponent parent)
	{
		return MechHardpoint(AddPart(part, fw,lr,ud, parent));
	}
	
	clearscope virtual void getHardpoints(out Array<MechHardpoint> hardpoints, bool skipDestroyed = true)
	{
		for(int i = 0; i < parts.Size(); i++)
		{	
			let hardpoint = MechHardpoint(parts[i]);
			if( !hardpoint || (hardpoint.healthPoints <= 0 && skipDestroyed) ) continue;
			
			hardpoints.Push(hardpoint);
		}
	}
	
	clearscope virtual MechItem FindItem(class<MechItem> item, bool subclass = false)
	{
		for(int i = 0; i < parts.Size(); i++)
		{
			let part = MechHardpoint(parts[i]);
			if(!part) continue;
			
			let found = part.FindItem(item, subclass);
			if(found) return found;
		}
		return NULL;
	}
	
	clearscope string getMechItemIndex(MechItem item)
	{
		for(int i = 0; i < parts.Size(); i++)
		{
			let hardpoint = MechHardpoint(parts[i]);
			if(!hardpoint) continue;
			
			for(int x = 0; x < hardpoint.items.Size(); x++)
			{
				if(hardpoint.items[x] == item)
					return String.Format("%d:%d", i, x);
			}
		}
		return "";
	}
	
	virtual MechHardpoint getAdjacentHardpoint(MechHardpoint from)
	{
		if(from ==  leftTorso) return torso;
		if(from == rightTorso) return torso;
		if(from ==    leftArm) return leftTorso;
		if(from ==   rightArm) return rightTorso;
		
		// Used to be side torsos, but this felt really shitty if ammo exploded in the leg.
		if(from ==    leftLeg) return NULL; 
		if(from ==   rightLeg) return NULL;
		
		return NULL;
	}
	
	virtual double getHealthyPercent()
	{
		Array<MechHardpoint> hardpoints;
		getHardpoints(hardpoints, skipDestroyed:false);
		
		double maxHP;
		double curHP;
		foreach(hp : hardpoints)
		{
			maxHP += hp.maxHP;
			curHP += hp.healthPoints;
		}
		
		return curHP / maxHP;
	}
		
	override void SetupParts()
	{
		// Make this part invisible
		bInvisible = true;
		
		// Camera(s)
		camDrone = ThirdpersonCamera.Create(1,0,20, -100, 60);
		AttachPart(camDrone, self);
	}
	
	void DoCockpitSound(Sound snd, int channel = CHAN_BODY, int flags = CHANF_OVERLAP, double volume = 1.0)
	{
		if(!head) return;
		head.A_StartSound(snd, channel, flags, volume);
	}
	
	virtual void SetupItems()
	{

	}
	
	void ToggleCamera()
	{
		if(camActive == camDrone) 
			SetPilotCamera();
		else
			SetDroneCamera();
	}
	
	void SetDroneCamera()
	{
		camDrone.Set(driver);
		camActive = camDrone;
	}
	void SetPilotCamera()
	{
		SetDriverCamera(cam);
		camActive = cam;
	}
	
	// FFS this is ugly...
	virtual MechWeapon selectNextWeapon(Array<MechWeapon> weaps)
	{
		selectedWeapon++;
		if(selectedWeapon > weaps.Size()) selectedWeapon = 1;
		let weap = weaps[selectedWeapon-1];
		
		while(weap && !weap.checkSelectable()) 
		{
			selectedWeapon++;
			if(selectedWeapon > weaps.Size()) selectedWeapon = 1;
			weap = weaps[selectedWeapon-1];
		}
		return weap;
	}
		
	virtual MechWeapon selectPrevWeapon(Array<MechWeapon> weaps)
	{
		selectedWeapon--;
		if(selectedWeapon < 1) selectedWeapon = weaps.Size();
		let weap = weaps[selectedWeapon-1];
		
		while(weap && !weap.checkSelectable()) 
		{
			selectedWeapon--;
			if(selectedWeapon < 1) selectedWeapon = weaps.Size();
			weap = weaps[selectedWeapon-1];
		}
		return weap;
	}
	
	clearscope virtual MechWeapon getSelectedWeapon()
	{
		Array<MechWeapon> weaps, filteredWeaps;
		getAllWeapons(weaps, readDeadHardpoints:true);
	
		// This is clearscope and is called from UI, so we need to make sure
		// we don't access this with a selectedWeapon of 0.
		if(selectedWeapon < 0 || selectedWeapon > weaps.Size()) return NULL;
		
		return weaps[selectedWeapon-1];
	}
	
	virtual void WeaponsInteraction()
	{
		Array<MechWeapon> weaps, filteredWeaps;
		getAllWeapons(weaps, readDeadHardpoints:true);
		getAllWeapons(filteredWeaps);
		
		// Handle targetting
		HandleHoming(filteredWeaps);
		
		// Lose target if target is dead.
		if(curTarget && (curTarget.bCORPSE || curTarget.health <= 0) )
		{
			betty.Push("Betty/TargetDestroyed");
			curTarget = NULL;
		}
		
		if(filteredWeaps.Size() <= 0) return;
		if(selectedWeapon < 0) selectedWeapon = 1;
		if(selectedWeapon > weaps.Size()) selectedWeapon = weaps.Size();		
		
		MechWeapon weap = weaps[selectedWeapon-1];
		
		// Get next weapon if current is destroyed.
		if(weap && weap.checkDestroyed()) 
			weap = selectNextWeapon(weaps);

		if( getExtBtn(BT_WEAPPREV, DriverBtns.BTS_PRESSED) )
			weap = selectPrevWeapon(weaps);
		if( getExtBtn(BT_WEAPNEXT, DriverBtns.BTS_PRESSED) )
			weap = selectNextWeapon(weaps);
			
		if( getExtBtn(BT_GROUPPREV, DriverBtns.BTS_PRESSED) )
			selectedGroup--;
		if( getExtBtn(BT_GROUPNEXT, DriverBtns.BTS_PRESSED) )
			selectedGroup++;	
			
		if( getExtBtn(BT_WEAPONSTATE, DriverBtns.BTS_PRESSED) && weap )
			weap.ToggleState();
			
		if( getDriverBtn(BT_ZOOM, DriverBtns.BTS_PRESSED) )
			inCombatZoom = !inCombatZoom;
			
		// Targeting
		if( getExtBtn(BT_GETTARGET, DriverBtns.BTS_PRESSED) )
		{
			Actor prevTarget = curTarget;
			AcquireTarget();
			if(curTarget != prevTarget)
			{
				betty.Push("Betty/Targetting");
				DoCockpitSound("Mech/Target/New");
			}
		}
						
		// Group customization
		if(selectedGroup < 0) selectedGroup = 4;
		if(selectedGroup > 4) selectedGroup = 0;
		
		let group = weaponGroups[selectedGroup];
		uint gBit = (2**selectedGroup);
				
		if(weap && group && weap.isGroupable()) 
		{
			if( getExtBtn(BT_GROUPSET, DriverBtns.BTS_PRESSED) )
				weap.group ^= gBit;  

			if( getExtBtn(BT_GROUPCHF, DriverBtns.BTS_PRESSED) )
				group.chainfire = !group.chainfire;
		}
	}
	
	virtual void DriverInteraction()
	{
		double fm, sm;
		[fm, sm] = GetMoveInputs();
		
		if(driver.player)
		{
			UserCmd cmd = driver.player.cmd;
		}
	
		if(getDriverBtn(BT_CROUCH, DriverBtns.BTS_PRESSED))
		{
			// Unused 
			// Maybe add mech crouching? This will require modifications to a mech's leg model.
		}
		
		if(getExtBtn(BT_ITEMMAGNET, DriverBtns.BTS_DOWN))
		{
			// Pickup nearby items.
			let itemIt = ThinkerIterator.Create("Inventory");
			Inventory item;
			while( item = Inventory(itemIt.Next()) )
			{	
				double dist = torso.Distance3D(item);
				string itemMsg = item.PickupMessage();
				bool validItem = itemMsg != "$TXT_DEFAULTPICKUPMSG" && itemMsg != "";
				bool canPickup = validItem && driver.CheckSight(item) && item.CanPickup(driver) && !item.Owner;
				
				if( dist > 64 && dist < 256 && canPickup )
				{
					double str = clamp(DrivablesMath.fmap(dist, 32, 512, 0, 1.0), 0, 1.0);
					vector3 dir = level.vec3diff(item.pos, torso.pos);
					item.vel += dir * (0.1 * str);
					item.vel *= 0.8;
				}
				else if(canPickup && dist < 64)
				{
					item.Touch(driver);
				}
			}
		}
		
		bool clicked = getDriverBtn(BT_ATTACK, DriverBtns.BTS_PRESSED);
		if(getDriverBtn(BT_ATTACK, DriverBtns.BTS_DOWN)) 
		{
			FireWeapons(1, instantFire:clicked);
		}
		
		clicked = getDriverBtn(BT_ALTATTACK, DriverBtns.BTS_PRESSED);
		if(getDriverBtn(BT_ALTATTACK, DriverBtns.BTS_DOWN)) 
		{
			FireWeapons(2, instantFire:clicked);
		}
		
		clicked = getDriverBtn(BT_USER1, DriverBtns.BTS_PRESSED);
		if(getDriverBtn(BT_USER1, DriverBtns.BTS_DOWN)) 
		{
			FireWeapons(3, instantFire:clicked);
		}
		
		clicked = getDriverBtn(BT_USER2, DriverBtns.BTS_PRESSED);
		if(getDriverBtn(BT_USER2, DriverBtns.BTS_DOWN)) 
		{
			FireWeapons(4, instantFire:clicked);
		}
		
		clicked = getDriverBtn(BT_USER3, DriverBtns.BTS_PRESSED);
		if(getDriverBtn(BT_USER3, DriverBtns.BTS_DOWN)) 
		{
			FireWeapons(5, instantFire:clicked);
		}
								
		torsoLock = getExtBtn(BT_TORSOLOCK, DriverBtns.BTS_DOWN);
		armLock = getExtBtn(BT_ARMLOCK, DriverBtns.BTS_DOWN);
		
		if(getExtBtn(BT_ALIGNLEGS, DriverBtns.BTS_PRESSED))
			centerToLegs = true;
		
		if(getExtBtn(BT_ALIGNTORSO, DriverBtns.BTS_PRESSED))
			centerToTorso = true;
			
		if(getExtBtn(BT_STOPMECH, DriverBtns.BTS_PRESSED))
			throttle = 0;
				
		// Stop leg centering if we start moving legs.
		if(sm) centerToTorso = false;
		
		// UI controls.
		WeaponsInteraction();
		
		// Movement
		bool noLegs = leftLeg.healthPoints <= 0 && rightLeg.healthPoints <= 0;
		
		// Mech cannot move if both legs are broken.
		if(noLegs) 
		{
			throttle = 0;
			
			// No turning
			angVel = 0;
		}
		else
		{
			if(sv_mdr_simplemechmovement)
				DoSimpleMovement(fm, sm);
			else
				DoTankMovement(fm, sm);
		}
	}
	
	clearscope double, double NormalizeMoveInputs(double fm, double sm)
	{
		bool running = cv_run && cv_run.getBool();
		double moveRatio = gameinfo.normforwardmove[0] / gameinfo.normsidemove[0];
		double normFM = clamp((fm / (gameinfo.normforwardmove[0]*256.)) * (running ? 0.5 : 1), -1, 1);	
		double normSM = clamp((sm / (gameinfo.normsidemove[0]*256.)) * (running ? 0.5 : 1), -1, 1);	
		normSM /= (moveRatio * 0.8);
		
		return normFM, normSM;
	}
	
	virtual void DoTankMovement(double fm, double sm)
	{
		// Movement Math
		double throttleSpeed = 0.025;
		double throttleMove = throttleSpeed * DrivablesMath.sign(fm);
		let [normFM, normSM] = NormalizeMoveInputs(fm, sm);

		bool analogThrottle = abs(normFM) < 1.0 && (cv_analogthrottle && cv_analogthrottle.getBool());
	
		throttle = analogThrottle ? normFM : throttle + throttleMove;
	
		double maxSpdMod = (leftLeg.healthPoints <= 0 || rightLeg.healthPoints <= 0) ? 0.5 : 1.0;
		throttle = clamp(throttle, -0.5 * maxSpdMod, 1.0 * maxSpdMod);
		
		let mtorso = MechTorso(torso);
		if(mtorso) mtorso.infiniteTurnRange = mtorso.default.infiniteTurnRange;	
		
		// Slow down while turning
		if(vel.xy.length())
		{
			double dist = vel.xy.length() / 2.0;
			double omega = angVel*angVel;
			double pushBack = (dist * (omega*0.02));
			vector2 dir = AngleToVector(angle);
			angVel -= DrivablesMath.sign(angVel)*(pushBack * 3.0); 
			vel.xy -= dir * (pushBack * 1.25);
		}
		
		double legTurnSpeed = DegToTurnSpeed(MechLegs(legs).turnSpeed);
		
		if(onground)
		{
			angVel -= legTurnSpeed * DrivablesMath.sign(sm);
			angle += angVel;
		}
	
		if(centerToTorso && abs(angle - torso.angle) > 0.1)
		{
			double prev = angle;
			DrivablesMath.AngleSlerp(angle, torso.angle, legTurnSpeed*2.0);	
			legVel = (angle - prev);
		}
		else if(centerToTorso) 
			centerToTorso = false;
			
		if(centerToLegs && abs(angle - torso.angle) > 0.1)
		{
			double prev = torso.angle;
			DrivablesMath.AngleSlerp(torso.angle, angle, legTurnSpeed);
			driver.angle += (torso.angle - prev);
		}
		else if(centerToLegs)
			centerToLegs = false;
					
		driver.angle += angVel;
		if(abs(throttle) < throttleSpeed) throttle = 0;
		
		// Throttle decay
		if(cv_throttleDecay && cv_throttleDecay.getBool() && !fm)
			throttle *= 0.94;
		
	}
	
	virtual void DoSimpleMovement(double fm, double sm, bool useTurnSpeed = true)
	{
		// Normalize FM
		bool running = cv_run && cv_run.getBool();
		[fm, sm] = NormalizeMoveInputs(fm, sm);
	
		// Movement Math
		double legTurnDegs = (MechLegs(legs).turnSpeed / double(TICRATE)) * 2.0;
		double maxSpdMod = (leftLeg.healthPoints <= 0 || rightLeg.healthPoints <= 0) ? 0.5 : 1.0;
		
		let mtorso = MechTorso(torso);
		if(mtorso) mtorso.infiniteTurnRange = true;	
		
		if( (fm || sm) && onground && moveSpeedKPH > 0 )
		{
			// Move Inputs
			vector2 moveDir = (fm, -sm);
			double moveAngle = driver.angle + atan2(moveDir.y, moveDir.x);
			
			// Turn rate physics
			double lerpAmt = useTurnSpeed ? clamp(1 / (abs(angle - moveAngle) / legTurnDegs), 0.05, 0.35) : 0.1;
			double accelDirModifier = (cos(angle), sin(angle)) dot (cos(moveAngle), sin(moveAngle));
			if(accelDirModifier < 0) accelDirModifier = 0;
			
			angVel = lerpAmt * abs(angle - moveAngle);

			// Move and accelerate
			angle = DrivablesMath.LerpDegrees(angle, moveAngle, lerpAmt);			
			throttle = (1.0 * maxSpdMod) * (!fm ? abs(sm) : abs(clamp(fm, -0.5, 1.0)));
			
			vel += DrivablesMath.VecFromAngles(angle, pitch, moveSpeed * abs(accel) * accelDirModifier);
		}
		else
		{
			throttle *= 0.7;
		}
		
		angVel *= 0.75;
		
		int accelSign = fm < 0 ? -1 : 1;
		double moveAmt = !moveSpeedKPH ? 1 : accelKPH / moveSpeedKPH;
		accel = accelSign * DrivablesMath.Lerp(abs(accel), throttle, moveAmt / 10.);
		
		// Center to legs does not apply to this movement system.
		if(centerToLegs) centerToLegs = false;
	}
	
	virtual void DoShutdown()
	{
		throttle = 0;
		betty.Push("Betty/ShuttingDown");
		DoCockpitSound("Reactor/Shutdown");
		shutdown = true;
		
		torso.oldAngleOffs.y = 10;
		head.oldAngleOffs.y = 5;
	}
	
	virtual void DoPowerup()
	{
		DoCockpitSound("Reactor/Powerup");
		betty.Push("Betty/Powerup");
		powerupCycleTics = 35*2;
		shutdown = false;
		
		torso.oldAngleOffs.y = 0;
		head.oldAngleOffs.y  = 0;
	}
	
	override void OnDrive()
	{	
		// Don't do anything if the driver is dead.
		if(driver && driver.health <= 0 || driver.bCORPSE) return;
	
		super.OnDrive();
		
		if(DriverBtns.Get(BT_RELOAD, DriverBtns.BTS_PRESSED, driver))
			ToggleCamera();
		
		// Process timed power cycling.
		if( shutdownTimer > 0 && !(--shutdownTimer) )
		{
			// If overriden, don't shutdown.
			if(!overrideShutdown) 
				DoShutdown();
			else
				heatShutdown = false;
				
			shutdownTimer = 0;
			if(heatShutdown)
			{
				powerupTimer = 35*4;
				heatShutdown = false;
			}
		}
				
		if( powerupTimer > 0 && !(--powerupTimer) )
		{
			DoPowerup();
			powerupTimer = 0;
		}
		
		// More heat logic.
		if(curHeat > kelvinToBHU(400.0) && !heatWarn)
		{
			// TODO: Play heat warn sound here.
			// betty.Push("Betty/Heat/Warn");
			heatWarn = true;
		}
		
		if(curHeat > kelvinToBHU(600.0) && !heatCritical)
		{
			betty.Push("Betty/Heat/Critical");
			heatCritical = true;
		}
		
		if(curHeat > kelvinToBHU(900.0) && !heatShutdown && !shutdown)
		{
			if(!overrideShutdown) betty.Push("Betty/Heat/CriticalShutdown");
			shutdownTimer = 35*3; // Three seconds till shutdown.
			heatShutdown = true;
		}
		
		if(curHeat <= kelvinToBHU(300.0)) heatWarn = false;
		
		if(curHeat <= kelvinToBHU(500.0)) heatCritical = false;
		
		if(getHeatPerc() >= 0.85)
			DoCockpitSound("Mech/OverheatWarning", CHAN_ITEM, CHANF_OVERLAP|CHANF_LOOPING|CHANF_NOSTOP);
		else if(head) 
			head.A_StopSound(CHAN_ITEM);
			
		
		// System buttons (Active regardless of power-state)
		if(getExtBtn(BT_POWERCYCLE, DriverBtns.BTS_PRESSED))
		{
			if(shutdown) 
				DoPowerup();
			else
				DoShutDown();
		}
			
		// Override shutdown
		if ( getExtBtn(BT_OVRSHUTDWN, DriverBtns.BTS_PRESSED) && !shutdown )
		{
			overrideShutdown = !overrideShutdown;
			if(overrideShutdown) betty.Push("Betty/Shutdown/Override");
		}
		
		// Damage notification(s)
		double curHealthPerc = getHealthyPercent();
		if(curHealthPerc <= 0.35 && healthPerc > 0.35)
			betty.Push("Betty/DamageCritical");
		healthPerc = getHealthyPercent();
		
		// Powerup and shutdown states.
		powerupCycleTics = max(0, powerupCycleTics-1);
		if(shutdown || powerupCycleTics > 0) 
		{
			angVel *= 0.75;
			legVel *= 0.75;
			return;
		}
		
		// Movement code.
		
		// Get movement speed.
		if(engine) 
		{
			moveSpeedKPH = engine.getKPH(self);
			moveSpeed = MechEngine.getMechKPHSpeed(moveSpeedKPH);
		}
		else
			moveSpeed = moveSpeedKPH = 0;
		
		DriverInteraction();
		
		// Crossable lines
		if(pos.z <= floorz)
		{
			let blockLines = BlockLinesIterator.Create(self, 16);	
			while(blockLines.Next())		
			{
				let ln = blockLines.CurLine;
				bool crossable = ln.activation & (SPAC_Cross|SPAC_AnyCross);
				if(crossable) 
				{
					if(DrivablesMath.DistanceToLine(ln, pos.xy) > 16) continue;
					ln.Activate(driver, level.PointOnLineSide(pos.xy, ln), SPAC_Cross); 
				}
			}
		}
	}
	
	virtual void modifyHeat(double amt)
	{
		// Double cooling while shutdown.
		if(amt < 0 && shutdown) amt *= 2.0;
		
		curHeat += amt;
		curHeat = clamp(curHeat, getAmbient(), maxHeat);	
	}
	
	clearscope virtual double kelvinToBHU(double K)
	{
		double kelvinPerc = K / maxKelvin;
		return kelvinPerc * maxHeat;
	}
	
	clearscope virtual double BHUtoKelvin(double bhu)
	{
		double bhuPerc = bhu / maxHeat;
		return bhuPerc * maxKelvin;
	}
	
	clearscope virtual double getHeatPerc()
	{
		return curHeat / maxHeat;
	}
	
	virtual double getAmbient()
	{
		// Used to determine ambient temp.
		return kelvinToBHU(20.0);
	}
	
	override void DoPhysics()
	{	
		super.DoPhysics();
		
		if(!sv_mdr_simplemechmovement)
			DoThrottleAcceleration();
			
		double airFriction = 0.997;
		vel.xy *= onground ? MECHFRICTION : airFriction;
	}
	
	// For traditional mechwarrior styled movement.
	virtual void DoThrottleAcceleration()
	{
		// Movement
		double adjustedMoveSpeed = moveSpeed;
		if(onground && moveSpeedKPH > 0)
		{
			bool decel = (throttle < accel);
			double moveAmt = (decel ? decelKPH : accelKPH) / moveSpeedKPH;
			moveAmt /= TICRATE;
			
			if(accel != throttle)
			{
				moveAmt *= (decel ? -1 : 1);
				accel += moveAmt;
				
				if( abs(accel - throttle) < abs(moveAmt) ) accel = throttle;
				accel = clamp(accel, -0.5, 1.0);
			}
		}
		
		vel += DrivablesMath.VecFromAngles(angle, pitch, adjustedMoveSpeed * accel);
		if(!onground) accel *= MECHFRICTION;
				
		// Friction
		angVel *= 0.75;
		legVel *= 0.75;
	}
		
	clearscope virtual double GetSpd()
	{
		return !onground ? 0 : vel.xy.length() + abs((angVel+legVel) * 0.5);
	}
		
	clearscope static double unitsToKM(double units)
	{
		return ( units * UTOCM ) / 100000.0;
	}
	clearscope static double MetersToUnits(double meters)
	{
		double UTOM = UTOCM / 100.0;
		return ( meters / UTOM );
	}
	
	clearscope static double DegToTurnSpeed(double degreeSeconds)
	{
		return degreeSeconds / 140.0; // Needs to be recalculated if turn friction is changed.
	}
	
	virtual MechEngine GetEngine()
	{
		engine = MechEngine(FindItem("MechEngine", true));		
		return engine;
	}
	
	// Lifetime is in HUD animation tics; 60 == 1 second.
	virtual void SendHUDMessage(string msg, int lifetime = 180, string msgID = "")
	{
		if(!driver) return;
		string ev = String.Format("hud>notify>%s>%s", msg, msgID);
		
		EventHandler.SendInterfaceEvent(driver.PlayerNumber(), ev, lifetime);
	}
	
	override void Tick()
	{
		GetEngine(); // Update engine.
		super.Tick();
		
		if(!betty) 
			betty = SoundQueue.Create(self);
		else if(driver)
			betty.local = driver;
		
		betty.active = (driver != NULL);
		
		if( (throttle-prevThrottle) < -0.25 )
		{
			A_StartSound("Engine/Forward", CHAN_5, CHANF_OVERLAP);
			prevThrottle = throttle;
		}
		if( (throttle-prevThrottle) >  0.25 )
		{
			A_StartSound("Engine/Back", CHAN_5, CHANF_OVERLAP);
			prevThrottle = throttle;
		}
			
		if(!shutdown && abs(throttle) > 0.1)
		{
			A_StartSound("Engine/Idle", CHAN_7, CHANF_LOOPING);
		}
		else
		{
			A_StopSound(CHAN_7);
		}
		
		// Keep track of persistent items.
		if(!engine && !shutdown) DoShutdown();
		if(armorType) armorType.DoEffect();
		
		// Weapon groups think too! This is needed for weapon cycle timing on Chainfire.
		for(int i = 0; i < weaponGroups.Size(); i++)
		{
			let grp = weaponGroups[i];
			if(grp) grp.DoEffect();
		}
		
		// mdr mechscale
		double desiredScale = GetMechScale();
		if(cachedScale != desiredScale)
		{
			A_SetScale(cachedAutoFit * desiredScale); 
			cachedScale = desiredScale;
		}
		
		// Get aim position
		aimingPos = DrivablesMath.getActorAim(cam);
		
		// Might need to fetch CVars again if loaded from a save.
		if(driver && driver.player && !cv_throttleDecay) FetchCVars();
		
		// Clear exited pilot once they're a sufficient distance away.
		if(exitedPilot && Distance2D(exitedPilot) >= (128 * scale.X)) exitedPilot = NULL;
		
		// Automatically take pilot if given one.
		// Everything needs a couple tics to setup properly before this is done.
		if(autoTakePilot && GetAge() > 4)
		{
			torso.angle = autoTakePilot.angle;
			TakePilot(autoTakePilot);
			autoTakePilot = NULL;
			//shutdown = false;
		}
		
		// Interference reduces over time.
		EMI *= 0.8;
	}
	
	States
	{
		Spawn:
			MECH A -1;
		stop;
	}
}

// Convert mechs into data so they can be saved between runs.
class HardpointSaveData : Object
{
	Array<MechItem> items;
	double armorPoints, rearArmor, maxRearArmor, healthPoints, maxArmor, maxHP, armorDamage, rearArmorDamage;
	
	virtual HardpointSaveData MakeCopy()
	{
		let hpData = new("HardpointSaveData");
		hpData.armorPoints = armorPoints;
		hpData.healthPoints = healthPoints;
		hpData.rearArmor = rearArmor;
		hpData.maxRearArmor = maxRearArmor;
		hpData.maxArmor = maxArmor;
		hpData.maxHP = maxHP;
		hpData.armorDamage = armorDamage;
		hpData.rearArmorDamage = rearArmorDamage;
		
		foreach(itm : items)
			hpData.items.Push(itm.MakeCopy());
		
		return hpData;
	}
	
	virtual void Save(MechHardpoint src, bool saveItems = true)
	{
		if(saveItems) items.Copy(src.items);
		armorPoints = src.armorPoints;
		healthPoints = src.healthPoints;
		rearArmor = src.rearArmor;
		maxRearArmor = src.maxRearArmor;
		maxArmor = src.maxArmor;
		maxHP = src.maxHP;
		armorDamage = src.armorDamage;
		rearArmorDamage = src.rearArmorDamage;
	}
	
	play virtual void Load(MechHardpoint dest)
	{
		dest.armorPoints = armorPoints;
		dest.healthPoints = healthPoints;
		dest.maxArmor = maxArmor;
		dest.rearArmor = rearArmor;
		dest.maxRearArmor = maxRearArmor;
		dest.maxHP = maxHP;
		dest.armorDamage = armorDamage;
		dest.rearArmorDamage = rearArmorDamage; 
		
		// Item loading is done after this, as it needs to be done
		// in a specific order.
	}
}
class MechSaveData : Object
{
	class<MechEngine> engineType;
	class<MechArmor> armorType;
	class<MechChassisStructure> chassisStructure; 
	class<DrivableMech> mechType;
	Array<HardpointSaveData> hardpointData;
	Array<MechWeaponGroup> weaponGroups;
	DrivableMech mechobj; // This mech's active Map Object.
	int mechbayID;
	
	// Shop information
	Array<String> ShopStats;
	Array<String> ShopValues;
	string shopDescription;
	
	virtual MechSaveData MakeCopy()
	{
		let saveData = MechSaveData(new(getClass()));
		saveData.engineType = engineType;
		saveData.armorType = armorType;
		saveData.chassisStructure = chassisStructure;
		saveData.mechType = mechType;
		saveData.ShopStats.Copy(ShopStats);
		saveData.ShopValues.Copy(ShopValues);
		saveData.shopDescription = shopDescription;
		
		foreach(hp : hardpointData)
			saveData.hardpointData.Push(hp.MakeCopy());
		
		foreach(grp : weaponGroups)
			saveData.weaponGroups.Push(grp.MakeCopy());
			
		return saveData;
	}
	
	virtual void Cache(DrivableMech src)
	{
		// Used for implementing custom save data
	}
	
	play virtual void RestoreCache(DrivableMech dest)
	{
		// Restore custom save data
	}
} 

class MechLoader : Actor
{
	DrivableMech mech;
	MechSaveData data;
	
	virtual void LoadMech()
	{
		if(!mech || !data) return;
		mech.noItemSlots = false;
		
		Array<MechHardpoint> hardpoints;
		mech.getHardpoints(hardpoints);

		for(int i = 0; i < hardpoints.Size(); i++)
		{
			let hardpointData = data.hardpointData[i];
			let hardpoint = hardpoints[i];
			
			// Restore vitals
			hardpointData.Load(hardpoint);
		}
		
		// We have to waste more time here to populate things in a specific order
		// Annoying but, not really another option.
		
		// Firstly, move all critical structures.
		for(int i = 0; i < hardpoints.Size(); i++)
		{
			let hardpointData = data.hardpointData[i];
			let hardpoint = hardpoints[i];
			
			for(int x = 0; x < hardpointData.items.Size(); x++)
			{
				let item = hardpointData.items[x];
				if(item.nosave || item.movable) continue; // Do not restore non-save-able items.
				
				item.TryAttach(hardpoint, forced:true);
			}
		}
		
		// Attach engine, armor and internal structure
		if(data.engineType) mech.torso.addItem(data.engineType);
		if(data.armorType ) MechArmor.addToMech(mech, data.armorType);
		if(data.chassisStructure) MechChassisStructure.addToMech(mech, data.chassisStructure);
		
		// Move non-critical structures
		for(int i = 0; i < hardpoints.Size(); i++)
		{
			let hardpointData = data.hardpointData[i];
			let hardpoint = hardpoints[i];
			
			for(int x = 0; x < hardpointData.items.Size(); x++)
			{
				let item = hardpointData.items[x];
				if(item.nosave || !item.movable) continue; // Do not restore non-save-able items.
				
				item.TryAttach(hardpoint, forced:true);
			}
		}
		
		// Restore weapon groups
		mech.weaponGroups.Copy(data.weaponGroups);
		
		// Restore misc fields
		data.RestoreCache(mech);
	}
	
	States
	{
		Spawn:
			TNT1 A 4;
			TNT1 A 0 LoadMech();
		stop;
	}
}

class I_SaveMechData : Inventory
{
	int activeMechID; // Currently active mech by MechbayID.
	DrivableMech lastPilotedMech;
	
	Array<MechSaveData> mechsData;
	Array<MechSaveData> defaultMechs; // Used in shop
	
	Default
	{
		Inventory.MaxAmount 1;
		+INVENTORY.UNDROPPABLE;
		-INVENTORY.INVBAR;
	}
	
	virtual void GiveMech(class<DrivableMech> mechClass)
	{
		let mech = CreateMech(mechClass);
		if(mech)
		{	
			// Save the mech.
			saveMechData(mech);
			
			// Remove template mech
			mech.Destroy();
		}
	}
	
	virtual int getAvailableMechbay()
	{
		if(!mechsData.Size()) return 1;

		int curMechbay = 1;
		foreach(mechData : mechsData)
		{
			if(mechData.mechbayID == curMechbay)
				curMechbay++;
		}
		
		return curMechbay;
	}
	
	virtual void AddSavedMech(MechSaveData mechData)
	{
		mechsData.Push(mechData);
		mechData.mechbayID = getAvailableMechbay();
	}
	
	play DrivableMech CreateMech(class<DrivableMech> mechClass)
	{
		let mech = DrivableMech(Spawn(mechClass));
		if(mech)
		{
			// Make sure mech is setup properly.
			mech.BeginPlay();
			mech.PostBeginPlay();
			mech.Tick();
		}
		return mech;
	}
	
	play MechSaveData CopyMechData(MechSaveData data)
	{
		return data.MakeCopy();
	}
	
	virtual void RecycleActiveMechs()
	{
		let drvObj = I_DrivingObject.Get(Owner);
		if(drvObj && drvObj.source is "DrivableMech") 
		{
			drvObj.source.RemovePilot();
			drvObj.source.Destroy();
		}
	
		foreach(mechData : mechsData)
		{
			let mechobj = mechData.mechobj;
			if(!mechobj) continue;
			
			saveMechData(mechobj);
			mechobj.Destroy();
		}
	}
	
	virtual void ReloadMechbays()
	{
		// Save and destroy all active mechs
		RecycleActiveMechs();
	
		// Re-activate each bay.
		let bayIt = ThinkerIterator.Create("MechBay");
		Mechbay bay;
		while(bay = MechBay(bayIt.Next()))
			bay.Activate(Owner);
	}
	
	virtual void RemoveMech(int mechbayID, bool reloadMechbays = true)
	{
		// Get mech saveID
		for(int i = 0; i < mechsData.Size(); i++)
		{
			let curMechData = mechsData[i];
			if(curMechData.mechbayID == mechbayID)
			{
				// Destroy active mech actor
				if(curMechData.mechobj) 
					curMechData.mechobj.Destroy();
				
				// Remove mech
				mechsData.Delete(i);
				break;
			}
		}
		
		// Update existing mech's save IDs
		for(int i = 0; i < mechsData.Size(); i++)
		{
			let curMechData = mechsData[i];
			let mechobj = curMechData.mechobj;
			if(!mechobj) continue;
			
			mechobj.saveID = i+1;
		}
		
		// Reload mechbays
		if(reloadMechbays) ReloadMechbays();
	}
	
	virtual void SwapMechbays(int bayOne, int bayTwo)
	{
		let mechOne = mechsData[bayOne-1];
		let mechTwo = mechsData[bayTwo-1];
		
		mechOne.mechbayID = bayTwo;
		mechTwo.mechbayID = bayOne;
	}
	
	virtual MechSaveData getSerializedMechData(DrivableMech mech)
	{
		// Save basic mech data.
		let data = MechSaveData(new(mech.saveDataType));	
		data.mechType = mech.getClass();
		data.weaponGroups.Copy(mech.weaponGroups);
		data.engineType = mech.engine ? mech.engine.getClass() : NULL;
		data.armorType = mech.armorType ? mech.armorType.getClass() : NULL;
		data.chassisStructure = mech.chassisStructure ? mech.chassisStructure.getClass() : NULL;
		data.Cache(mech);
		
		// Populate shop information
		mech.GetShopProperties(data.ShopStats, data.ShopValues);
		data.shopDescription = mech.getShopDescription();
		
		Array<MechHardpoint> hardpoints;
		mech.getHardpoints(hardpoints, skipDestroyed:false);
		
		// Save hardpoint data
		for(int i = 0; i < hardpoints.Size(); i++)
		{
			let hardpoint = hardpoints[i];
			
			HardpointSaveData hardpointData = new("HardpointSaveData");
			hardpointData.Save(hardpoint, saveItems:true);
			
			data.hardpointData.push(hardpointData);
		}
		
		return data;
	}
	
	virtual void saveMechData(DrivableMech mech)
	{	
		let data = getSerializedMechData(mech);
		
		// Add mech save data to mechbays
		if(!mech.saveID)
		{
			AddSavedMech(data);
			mech.saveID = mechsData.Size();
		}	
		else
		{
			// If this mech has existing mechbay data, reload it.
			if(mech.saveID <= mechsData.Size())
			{
				// Rewrite mechbay ID.
				int mechbayID = mechsData[mech.saveID-1].mechbayID;
				data.mechbayID = mechbayID;
				
				mechsData.Delete(mech.saveID-1);
				mechsData.Insert(mech.saveID-1, data);
			}
		}	
		// console.printf("Saved to mechbay: %d", mech.mechbayID);
	}
	
	clearscope DrivableMech getMechbayMech(int mechbayID)
	{
		MechSaveData mechData;
		foreach(mech : mechsData)
		{
			if(mech.mechbayID == mechbayID)
				mechData = mech;
		}
		if(!mechData) return NULL;

		return mechData.mechobj;
	}
	
	clearscope MechSaveData getSavedMech(int mechbayID)
	{
		MechSaveData mechData;
		foreach(mech : mechsData)
		{
			if(mech.mechbayID == mechbayID)
				return mech;
		}
		return NULL;
	}
	
	virtual DrivableMech loadMechData(int mechbayID, vector3 atPos, double atAngle = 0)
	{
		int mechSaveID = -1;
		MechSaveData mechData;
		for(int i = 0; i < mechsData.Size(); i++)
		{
			let curMechData = mechsData[i];
			if(curMechData.mechbayID == mechbayID)
			{
				mechData = curMechData;
				mechSaveID = i;
			}
		}	
		if(!mechData) return NULL;

		// Destroy old mechs of this same type.
		if(mechData.mechobj)
			mechData.mechobj.Destroy();
		
		// Respawn mech.
		let mech = DrivableMech(Spawn(mechData.mechType, atPos));
		if(mech) 
		{
			mech.angle = atAngle;
			mech.saveID = mechSaveID+1;
			mech.noItemSlots = true;
			mech.MechSerializer = self; // Restore mech save data serializer.
			
			// Mech loader needs to be spawned to ensure that mech is 
			// properly initialized with noItemSlots before mech data is 
			// actually loaded.
			let loader = MechLoader(Spawn("MechLoader", atPos));
			loader.mech = mech;
			loader.data = mechData;
			mechData.mechobj = mech;
		}
		return mech;
	}
	
	override void AttachToOwner(Actor other)
	{
		// Give mechs
		super.AttachToOwner(other);
		
		// Setup shop mechs
		foreach(cls : AllActorClasses)
		{
			let mechcls = (class<DrivableMech> )(cls);
			if(!mechcls || mechcls == "DrivableMech") continue;
			
			let mechObj = CreateMech(mechcls);
			let shopMech = getSerializedMechData(mechObj);
			defaultMechs.Push(shopMech);
			mechObj.Destroy();
		}		
		
		// DEBUG
		GiveMech("MechCenturion");
		
		/*
			GiveMech("MechJenner");
			GiveMech("MechHellbringer");
			GiveMech("MechMarauderIIC");
			GiveMech("MechTimberwolf");
			GiveMech("MechCenturion");
		*/
	}

	override void DoEffect()
	{
		super.DoEffect();
		
		let plr = Owner.player;
		if(!plr) return;
		
		let btns = plr.cmd.buttons;
		let obtns = plr.oldbuttons;
		
		// Saving and loading debug
		/*
		if( (btns & BT_RELOAD) && !(obtns & BT_RELOAD) )
		{
			if(mechsData.Size() <= 0) return;
			console.printf("Restoring mechbay 1...");

			loadMechData(0, Owner.pos + (100,0,0));
		}
		
		if( (btns & BT_ZOOM) && !(obtns & BT_ZOOM) )
		{
			let veh = I_DrivingObject.Get(Owner);
			if(!veh) return;
			
			let mech = DrivableMech(veh.source);
			if(!mech) return;
			
			saveMechData(mech);
		}
		*/
	}
}
